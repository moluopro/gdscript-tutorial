import{_ as a,c as o,o as l,ag as r}from"./chunks/framework.xT_8jeIh.js";const u=JSON.parse('{"title":"集合","description":"","frontmatter":{},"headers":[],"relativePath":"7.collections/index.md","filePath":"7.collections/index.md"}'),t={name:"7.collections/index.md"};function i(p,e,n,c,d,s){return l(),o("div",null,[...e[0]||(e[0]=[r('<h1 id="集合" tabindex="-1">集合 <a class="header-anchor" href="#集合" aria-label="Permalink to &quot;集合&quot;">​</a></h1><p>集合，任意对象类型的泛型序列，包括数组、紧缩数组或字典</p><p>在本章中，我们将会初步了解GDScript中的集合类型</p><p>集合在GDScript中属于内置容器类型，正如其名，它们是一种数据容器，用于储存多个数据</p><p>集合类型属于引用类型<code>Variant</code>，这意味着，它们始终按引用传递，<strong>修改其元素会影响原始集合</strong></p><p>集合类型主要分为以下三种：</p><ul><li><p><a href="./7.1.array.html">数组</a>：任意类型的泛型有序序列，提供一系列便利方法</p></li><li><p><a href="./7.2.packed-array.html">紧缩数组</a>：静态类型有序序列，大批量数据下拥有更佳的性能，支持的数据类型有限</p></li><li><p><a href="./7.3.dictionary.html">字典</a>：关联容器，使用键值对来对数据进行查询修改，字典所擅长的任务是数组所不擅长的，在插入/删除/移动方面最快</p></li></ul><h1 id="数据偏好" tabindex="-1">数据偏好 <a class="header-anchor" href="#数据偏好" aria-label="Permalink to &quot;数据偏好&quot;">​</a></h1><blockquote><p>更详细的内容见官方文档： <a href="https://docs.godotengine.org/zh-cn/4.x/tutorials/best_practices/data_preferences.html" target="_blank" rel="noreferrer">最佳实践-数据偏好</a></p></blockquote><p>GDScript有三种数据结构，<code>Array</code>数组、<code>Dictionary</code>字典、<code>Object</code>对象</p><h2 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h2><p>这个术语来自于算法分析中的大O表示法</p><p>它描述了最坏情况下的运行时长大概有多慢：</p><p>“随着问题域的大小增加，算法的运行时长……”</p><ul><li><p>常量时间，<code>O(1)</code>：“……不会增加。”（极快）</p></li><li><p>对数时间，<code>O(log n)</code>：“……会以较慢的速度增长。”</p></li><li><p>线性时间，<code>O(n)</code>：“……会以相同的速度增长。”（数据越多耗时越长）</p></li><li><p>平方时间，<code>O(n²)</code>：“……会以很快的速度增长。”（极慢）</p></li></ul><p>比如：</p><ul><li><p>用数组查找第5个元素，是<code>O(1)</code></p></li><li><p>用数组查找“值为42”的元素，是<code>O(n)</code></p></li><li><p>用字典通过key取值，是<code>O(1)</code></p></li><li><p>用字典查找“谁的值是42”，是<code>O(n)</code></p></li></ul><h2 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h2><p>数组就像一排编号整齐的箱子，每个格子可以放一个东西（值），我们可以通过“编号”快速找到某个格子。</p><p>适合场景：<strong>顺序存放数据、需要遍历、按索引访问的情况</strong></p><ul><li><p><strong>迭代非常快</strong> —— 只要往前走一步就能拿到下一个格子</p></li><li><p><strong>按位置取值最快</strong> —— 想拿第 3 个元素？直接看第 3 个格子就好</p></li><li><p><strong>查找值很慢</strong> —— 要找特定内容，只能一个个翻过去看（就像找钥匙那样）</p></li><li><p><strong>在中间插入或删除元素较慢，在开头插入删除元素最慢</strong> —— 插个值要把后面一堆格子全挪一挪</p></li><li><p><strong>在末尾添加或删除最快</strong></p></li></ul><p>如果你经常要在开头插入或删除元素，可以先把数组用<code>reverse()</code> 反转，再在结尾操作，最后再反转回来，就可以避免性能瓶颈</p><h2 id="字典" tabindex="-1">字典 <a class="header-anchor" href="#字典" aria-label="Permalink to &quot;字典&quot;">​</a></h2><p>字典是用“键(key)”来找值的，就像翻电话簿一样可以直接找到联系人，而不需要知道他排第几。</p><p>适合场景：<strong>按名字或标签快速访问数据、结构更灵活的存储</strong></p><ul><li><p><strong>插入、删除、查找都很快</strong> —— 因为用了“哈希算法”（就是把 key 快速转换成地址）</p></li><li><p><strong>迭代也很快</strong> —— 默认会保留插入顺序（可以按顺序遍历）</p></li><li><p><strong>按 key 取值设值最快</strong></p></li><li><p><strong>按值找 key 很慢</strong> —— 字典不是为这设计的，需要遍历整本字典才能找</p></li></ul><h2 id="对象" tabindex="-1">对象 <a class="header-anchor" href="#对象" aria-label="Permalink to &quot;对象&quot;">​</a></h2><p>GDScript对象的特性不在本文讨论范围，详见后续面向对象章节</p><h2 id="使用建议" tabindex="-1">使用建议 <a class="header-anchor" href="#使用建议" aria-label="Permalink to &quot;使用建议&quot;">​</a></h2><ul><li><p>要跑得快用数组（迭代）</p></li><li><p>要记得谁是谁用字典</p></li><li><p>要高频操作时避免在数组中间插入元素</p></li><li><p>数据量一多就卡死？考虑使用更快的结构如紧缩数组，或协程</p></li></ul>',30)])])}const g=a(t,[["render",i]]);export{u as __pageData,g as default};
