import{_ as e,c as t,o as d,ag as c}from"./chunks/framework.xT_8jeIh.js";const a="/oss/gdscript-tutorial/introduction-to-code-structure/image.png",r="/oss/gdscript-tutorial/introduction-to-code-structure/image-15.gif",i="/oss/gdscript-tutorial/introduction-to-code-structure/image-16.gif",s="/oss/gdscript-tutorial/introduction-to-code-structure/image-1.png",p="/oss/gdscript-tutorial/introduction-to-code-structure/image-2.png",n="/oss/gdscript-tutorial/introduction-to-code-structure/image-3.png",l="/oss/gdscript-tutorial/introduction-to-code-structure/image-4.png",u="/oss/gdscript-tutorial/introduction-to-code-structure/image-17.gif",h="/oss/gdscript-tutorial/introduction-to-code-structure/image-5.png",g="/oss/gdscript-tutorial/introduction-to-code-structure/image-6.png",_="/oss/gdscript-tutorial/introduction-to-code-structure/image-7.png",m="/oss/gdscript-tutorial/introduction-to-code-structure/image-8.png",k="/oss/gdscript-tutorial/introduction-to-code-structure/image-9.png",b="/oss/gdscript-tutorial/introduction-to-code-structure/image-10.png",q="/oss/gdscript-tutorial/introduction-to-code-structure/image-11.png",f="/oss/gdscript-tutorial/introduction-to-code-structure/image-12.png",y="/oss/gdscript-tutorial/introduction-to-code-structure/image-13.png",x="/oss/gdscript-tutorial/introduction-to-code-structure/image-14.png",C=JSON.parse('{"title":"前言","description":"","frontmatter":{},"headers":[],"relativePath":"2.introduction-to-code-structure.md","filePath":"2.introduction-to-code-structure.md"}'),E={name:"2.introduction-to-code-structure.md"};function P(D,o,G,N,v,T){return d(),t("div",null,[...o[0]||(o[0]=[c('<h1 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h1><p><strong>GDScript</strong>是基于<strong>Godot</strong>游戏引擎环境的一种面向对象的高级编程语言</p><p>也就是说<strong>GDScript</strong>的代码在<strong>Godot</strong>的环境下才能够运行，为了方便学习我们首先需要了解一下该怎样运行<strong>GDScript</strong>脚本</p><h1 id="选择编辑器" tabindex="-1">选择编辑器 <a class="header-anchor" href="#选择编辑器" aria-label="Permalink to &quot;选择编辑器&quot;">​</a></h1><p>在学习GDScript之前需要选择一个合适的Godot编辑器</p><p><img src="'+a+'" alt=""></p><p><strong>如果需要用到C#脚本编写的插件或需要用到C#语言作为Godot的脚本语言（之一），则下载.NET版本，如果不需要使用C#则下载通常版本即可</strong></p><h1 id="创建脚本" tabindex="-1">创建脚本 <a class="header-anchor" href="#创建脚本" aria-label="Permalink to &quot;创建脚本&quot;">​</a></h1><p>下载完Godot编辑器并新建一个项目之后，我们便可以新建一个GDScript脚本文件，以下两种方法都可以创建脚本，选择方便的来即可（创建的时候记得选择Node:Default模板）</p><h2 id="在文件系统中创建脚本" tabindex="-1">在文件系统中创建脚本 <a class="header-anchor" href="#在文件系统中创建脚本" aria-label="Permalink to &quot;在文件系统中创建脚本&quot;">​</a></h2><p><img src="'+r+'" alt=""></p><h2 id="在节点上创建脚本" tabindex="-1">在节点上创建脚本 <a class="header-anchor" href="#在节点上创建脚本" aria-label="Permalink to &quot;在节点上创建脚本&quot;">​</a></h2><p>这种方法创建的脚本会直接令脚本挂载到目标节点上</p><p><img src="'+i+'" alt=""></p><h1 id="代码结构" tabindex="-1">代码结构 <a class="header-anchor" href="#代码结构" aria-label="Permalink to &quot;代码结构&quot;">​</a></h1><p><img src="'+s+'" alt=""></p><p><strong>这是GDScript中最常见的一个代码结构，其中</strong></p><ul><li><p>井号（<code>#</code>）开头表示这是一行注释，用于说明代码用途，井号后的文字在程序执行时都将被省略</p></li><li><p>其余部分则是源代码</p></li></ul><h2 id="_1-extends-node" tabindex="-1">1. <code>extends Node</code> <a class="header-anchor" href="#_1-extends-node" aria-label="Permalink to &quot;1. `extends Node`&quot;">​</a></h2><p>在这一行代码中，如果你使用的是Godot编辑器内置的脚本编辑器你可能会注意到</p><ul><li><p><code>extends</code>是红色的：这表明它是GDScript中的一个<strong>关键字</strong></p></li><li><p><code>Node</code>是绿色的：这表明它是一个<strong>类</strong></p></li></ul><blockquote><p><strong>关键字（keyword）</strong> 指的是在GDScript中有特殊用途的单词，我们<strong>不能</strong>把它占用来作为变量名或方法名等标识符（identifier）的名字，比如你不能写一个叫<code>if</code>的变量，这是不被允许的~</p><p><strong>类（class）</strong> 面向对象编程（OOP）的一个概念，它相当于是一个大家庭，里面有各种各样的成员，各自负责不同的功能，目标一致地完成某项任务</p></blockquote><h3 id="关键字extends" tabindex="-1"><strong>关键字<code>extends</code></strong> <a class="header-anchor" href="#关键字extends" aria-label="Permalink to &quot;**关键字`extends`**&quot;">​</a></h3><p><code>extends</code>在这里的意思是表明要让这个类（当前的脚本文件）<strong>继承</strong>自某个已有的类</p><blockquote><p>就像是：我们要给这个大家族创建支系，新家族可以继承老家族的本领，和老家族的成员间来往，还能加入自己的特色，比如会唱歌、跳舞</p></blockquote><h3 id="类node" tabindex="-1"><strong>类<code>Node</code></strong> <a class="header-anchor" href="#类node" aria-label="Permalink to &quot;**类`Node`**&quot;">​</a></h3><p><code>Node</code> 是Godot中的一个<strong>超级重要的基础的</strong>类型，它是所有可被添加到场景对象的基类（BaseClass），Godot的游戏场景都是由一个个节点构建起来的。</p><p>比如这些常见的节点类型：</p><ul><li><p><code>Node2D</code> （用于2D游戏）</p></li><li><p><code>Node3D</code> （用于3D游戏）</p></li><li><p><code>Control</code>（用于UI元素）</p></li></ul><p>他们全都继承自<code>Node</code> ，像是同一个家族里的表亲一样，而<code>Node</code>则是他们共同的祖宗</p><p>所以这行代码表示：</p><p><strong>我们要给<code>Node</code> 这个大家族创建一个旁系</strong></p><blockquote><p><em>（我们要创建一个类，这个类继承自<code>Node</code>）</em></p></blockquote><p>这意味着，我们当前编写的脚本会拥有<code>Node</code> 的所有能力，同时我们也能给它添加独属于自己的能力</p><hr><h2 id="_2-func-ready-void-pass" tabindex="-1">2. <code>func _ready() -&gt; void: pass</code> <a class="header-anchor" href="#_2-func-ready-void-pass" aria-label="Permalink to &quot;2. `func _ready() -&gt; void: pass`&quot;">​</a></h2><p>在这段代码中，如果你使用的是Godot编辑器内置的脚本编辑器你可能会注意到</p><ul><li><p><code>func</code> 是红色的：这表明它是一个关键字；</p></li><li><p><code>_ready</code> 是蓝色的：这表明它是一个标识符；</p></li><li><p><code>void</code> 是绿色的：虽然绿色在内置脚本编辑器通常表明一种类型，但是它比较特殊，它是一个<strong>关键字</strong> ；</p></li><li><p><code>pass</code> 是红色的：这表明它也是一个关键字；</p></li></ul><blockquote><p><strong>标识符（identifier）</strong> 是用于标识变量、方法、类等等成员的符号，相当于是给家庭成员起的一个名字</p></blockquote><h3 id="关键字func" tabindex="-1"><strong>关键字<code>func</code></strong> <a class="header-anchor" href="#关键字func" aria-label="Permalink to &quot;**关键字`func`**&quot;">​</a></h3><p><code>func</code> 这个单词的意思是我们要声明一个方法(Method)，也可以叫函数( Function），他是类的成员之一，相当于是家庭成员能做的一件“事情”</p><h3 id="标识符-ready" tabindex="-1"><strong>标识符<code>_ready</code></strong> <a class="header-anchor" href="#标识符-ready" aria-label="Permalink to &quot;**标识符`_ready`**&quot;">​</a></h3><p><code>_ready</code> 作为标识符，是方法的名字，不过以 <code>_</code> 开头的名字一般代表 Godot 提供的“可覆盖方法”</p><h3 id="关键字void" tabindex="-1"><strong>关键字<code>void</code></strong> <a class="header-anchor" href="#关键字void" aria-label="Permalink to &quot;**关键字`void`**&quot;">​</a></h3><p><code>void</code> 这个单词的意思是表示这个函数<strong>不会返回任何值</strong></p><blockquote><p>就像你让某位家庭成员去买菜，他回来后不会跟你说买了什么～他只是默默完成任务</p></blockquote><h3 id="关键字pass" tabindex="-1"><strong>关键字<code>pass</code></strong> <a class="header-anchor" href="#关键字pass" aria-label="Permalink to &quot;**关键字`pass`**&quot;">​</a></h3><p><code>pass</code> 用来占位，不执行任何操作。</p><p>当你在定义函数或其他代码块时暂时还没写内容，就可以先写个<code>pass</code> ，表示“我知道这里需要代码，你别急，我在烧烤(思考)”</p><p>这样就不会报错</p><p>否则你会遇到如下错误</p><blockquote><p><code>Expected indented block after function declaration.</code></p><p><em>（函数声明后应有缩进块）</em></p></blockquote><h3 id="ready-方法" tabindex="-1"><strong><code>_ready()</code>方法</strong> <a class="header-anchor" href="#ready-方法" aria-label="Permalink to &quot;**`_ready()`方法**&quot;">​</a></h3><p><code>ready()</code>方法是属于<code>Node</code>类的一个可覆盖方法（Virtual Method），可以在子类中重写（override）实现自定义逻辑</p><ul><li><p>它没有任何参数和返回值。</p></li><li><p><code>_ready()</code> 只会在节点及其子节点全部准备好后调用</p></li><li><p>它只会在每个节点上被调用一次</p></li><li><p>只会在第一次进入场景树时调用，如果当该节点从树中移除后重新添加，<code>_ready()</code> 方法不会被调用，除非使用<code>request_ready()</code>方法</p></li></ul><p><code>_ready()</code> 方法一般用于<strong>初始化逻辑</strong></p><p>比如：加载资源、连接信号、设置初始状态</p><blockquote><p><strong>可覆盖方法</strong> 也叫虚函数/虚方法（virtual）, 表示这个方法可以在子类中重写（override），实现与父类不同的逻辑，在GDScript中，<strong>下划线开头</strong>的方法，一般都是Godot 提供的“虚方法”，我们可以在自己的类里重写它来自定义逻辑</p></blockquote><h3 id="官方文档" tabindex="-1">官方文档 <a class="header-anchor" href="#官方文档" aria-label="Permalink to &quot;官方文档&quot;">​</a></h3><blockquote><p><strong>● <code>void _ready() virtual</code></strong></p><p>当节点“就绪”时被调用，即当节点及其子节点都已经进入场景树时。如果该节点有子节点，将首先触发子节点的 <code>_ready()</code> 回调，稍后父节点将收到就绪通知。</p><p>对应 <code>Object._notification()</code> 中的 <code>NOTIFICATION_READY</code> 通知。另请参阅用于变量的 <code>@onready</code> 注解。</p><p>通常用于初始化。对于更早的初始化，可以使用 <code>Object._init()</code>。另见 <code>_enter_tree()</code>。</p><p>注意：该方法对于每个节点可能仅调用一次。从场景树中移除一个节点后，并再次添加该节点时，将不会第二次调用 <code>_ready()</code>。这时可以通过使用 <code>request_ready()</code>，它可以在再次添加节点之前的任何地方被调用。</p><h4 id="文档摘要" tabindex="-1">文档摘要 <a class="header-anchor" href="#文档摘要" aria-label="Permalink to &quot;文档摘要&quot;">​</a></h4><ul><li><p>当节点“就绪”时被调用（即：当节点及其所有子节点都加入场景树之后）</p></li><li><p>如果该节点有子节点，<strong>子节点的 <code>_ready()</code> 会先被调用</strong>，然后才是父节点</p></li><li><p>对应于 <code>Object._notification()</code> 中的 <code>NOTIFICATION_READY</code></p></li><li><p>通常用于初始化</p></li><li><p>想更早初始化可以用 <code>_init()</code>，想更早响应节点加入场景树可使用 <code>_enter_tree()</code></p></li><li><p><strong>注意：默认每个节点 <code>_ready()</code> 只会被调用一次</strong></p></li><li><p>如果你将节点移除后又重新添加，可以使用 <code>request_ready()</code> 强制重新触发 <code>_ready()</code></p></li></ul></blockquote><hr><h2 id="_3-func-process-delta-float-void-pass" tabindex="-1">3. <code>func _process(delta: float) -&gt; void: pass</code> <a class="header-anchor" href="#_3-func-process-delta-float-void-pass" aria-label="Permalink to &quot;3. `func _process(delta: float) -&gt; void: pass`&quot;">​</a></h2><p>在这段代码中，如果你使用的是Godot编辑器内置的脚本编辑器你可能会注意到</p><ul><li><p><code>delta</code> 是白色的：这表明它是变量标识符，是一个变量。在这里，它是<code>_process</code>方法的一个参数</p></li><li><p><code>float</code> 是绿色的：它是一个类型<code>float</code> ，在GDSctipt中表示的是浮点数（小数）类型。在这里，它是参数<code>delta</code>的类型</p></li></ul><h3 id="参数delta" tabindex="-1"><strong>参数<code>delta</code></strong> <a class="header-anchor" href="#参数delta" aria-label="Permalink to &quot;**参数`delta`**&quot;">​</a></h3><p>它是<code>_process(float)</code>方法的一个参数，是<code>float</code>浮点数类型</p><p>表示帧时间也就是从上一帧到当前帧之间经过了多少秒（时间增量）单位是秒，是一个极小的量</p><p>受设备性能影响，在<code>_process(float)</code> 方法中，每一帧它的值都是不同的</p><blockquote><p><strong>时间增量（delta time）</strong> 表示在游戏主循环中，从上一帧到当前帧之间实际经过的时间，单位是秒。因为设备的刷新率和主循环的运行速度不同，每一帧的 <code>delta</code> 值也会有所不同。它能直接反映出每一帧的处理耗时，在需要让逻辑与帧率无关时非常有用！不过要注意，<code>delta</code> 是游戏内部的估算值，并不适合用来测量真实世界中的准确时间，想要更精准的时间信息，可以使用 <code>Time</code> 单例提供的方法</p></blockquote><h3 id="类型float" tabindex="-1"><strong>类型<code>float</code></strong> <a class="header-anchor" href="#类型float" aria-label="Permalink to &quot;**类型`float`**&quot;">​</a></h3><p>它是GDScript中的一种基本内置类型，不能够被继承，它表明一个浮点数（floating-point），也就是带小数点的数字</p><p>像是<code>1.5</code> <code>3.14</code> <code>-0.01</code> 这样的数字都属于<code>float</code></p><h3 id="process-float-方法" tabindex="-1"><strong><code>_process(float)</code> 方法</strong> <a class="header-anchor" href="#process-float-方法" aria-label="Permalink to &quot;**`_process(float)` 方法**&quot;">​</a></h3><p><code>_process(float)</code>是<code>Node</code>类的一个可覆盖方法，可以在自己写的类里重写它，实现属于自己的逻辑</p><ul><li><p>它是帧处理函数，会在游戏主循环的每一帧调用</p></li><li><p>它接收一个<code>float</code>类型的参数<code>delta</code>，如上文所说，表示帧时间</p></li><li><p>它没有返回值</p></li><li><p>为了尽可能快地处理，时间增量<code>delta</code> 参数每一帧都会发生变化</p></li><li><p>可以使用<code>set_process(bool)</code>来开关帧处理</p></li><li><p>如果 <code>_process(float)</code> 被覆盖，帧处理将在 <code>_ready()</code> 被调用之前自动启用。</p></li><li><p><code>_process(float)</code> 只有当节点<strong>在场景树中</strong>才会被调用（不能是孤立节点）</p></li><li><p>Godot 会根据 <code>process_priority</code> 来决定调用顺序：数值越小越先执行，同级的按照场景树顺序执行</p></li></ul><p><code>_process(float)</code> 一般用来处理 <strong>持续更新的逻辑</strong></p><p>比如：玩家输入检测、每秒计时器、自动保存游戏进度</p><h3 id="官方文档-1" tabindex="-1">官方文档 <a class="header-anchor" href="#官方文档-1" aria-label="Permalink to &quot;官方文档&quot;">​</a></h3><blockquote><p>●<code></code><strong><code>void _process(delta: float) virtual</code></strong></p><p>在主循环的处理步骤中调用。每一帧都会尽快进行处理，因此表示自上一帧以来时间增量的 <code>delta</code>会发生变化。<code>delta</code>的单位为秒。</p><p>启用处理后才会调用该方法，覆盖该方法后会自动启用，可以使用 <code>set_process()</code> 开关。</p><p>处理按照 <code>process_priority</code> 的顺序进行，优先级取值越低越先调用。优先级相同的节点按照树顺序处理，即编辑器中从上到下的顺序（也叫前序遍历）。</p><p>对应 <code>Object._notification()</code> 中的 <code>NOTIFICATION_PROCESS</code> 通知。</p><p>注意：节点位于场景树中才会调用该方法（即不能是孤立节点）。</p><p>注意：运行帧率小于 <code>Engine.physics_ticks_per_second</code> / <code>Engine.max_physics_steps_per_frame</code> FPS 时 <code>delta</code>会比正常情况大。这样做是为了避免产生“死亡螺旋”。在这种情况下，由于每帧物理步骤数量的不断增加，性能会急剧下降。<code>_process()</code> 和 <code>_physics_process()</code> 都会受此影响。因此，请避免根据 delta 来测量真实世界的秒数。请使用 Time 单例的方法来实现此目的，例如 <code>Time.get_ticks_usec()</code>。</p><h4 id="文档摘要-1" tabindex="-1">文档摘要 <a class="header-anchor" href="#文档摘要-1" aria-label="Permalink to &quot;文档摘要&quot;">​</a></h4><ul><li><p>在主循环的处理步骤中被调用。</p></li><li><p>会尽可能在每一帧中执行，参数 <code>delta</code> 是上一帧到当前帧之间的时间，单位是 <strong>秒</strong>。</p></li><li><p>重写该方法后，帧处理将自动启用</p></li><li><p>可用 <code>set_process(bool)</code> 控制启用状态</p></li><li><p>处理顺序受 <code>process_priority</code> 控制，数值越低优先级越高</p></li><li><p>只有在节点进入<strong>场景树</strong>后才会触发 <code>_process(float)</code></p></li><li><p><strong>低帧率时</strong>，为了避免“死亡螺旋”问题，<code>delta</code> 会被放大， 所以不建议用它来精确测量真实时间</p></li></ul></blockquote><hr><h2 id="另一种样式" tabindex="-1">另一种样式 <a class="header-anchor" href="#另一种样式" aria-label="Permalink to &quot;另一种样式&quot;">​</a></h2><p>除了上面那种带有类型声明的代码结构，你有时候可能还会看到 <strong>下面这种形式</strong>的脚本</p><p><img src="'+p+'" alt=""></p><p>如果你在 <strong>编辑器设置 → 文本编辑器 → 补全</strong> 页面里，<strong>没有勾选「添加类型提示」</strong> 的话，通过模板创建的脚本就会如上图所示</p><p><img src="'+n+'" alt=""></p><p>在这个结构里，像<code>func _ready()</code>和<code>func _process(delta)</code>这样的方法，没有声明返回类型(比如<code>-&gt; void</code>)或参数类型（比如 <code>delta: float</code>）</p><p>这并不是错误～而是 <strong>GDScript 的动态类型特性</strong></p><p>换句话说，它允许你<strong>不写出类型</strong>，而在运行时再根据实际情况自动判断</p><p>这种写法虽然方便，但也有一些缺点：</p><ul><li><p><strong>缺少代码提示</strong>，写代码的时候编辑器没法智能推断类型，提示会变少</p></li><li><p><strong>更容易出错</strong>，比如传错类型，可能会在运行时才发现问题</p></li></ul><h1 id="编写第一行代码" tabindex="-1">编写第一行代码 <a class="header-anchor" href="#编写第一行代码" aria-label="Permalink to &quot;编写第一行代码&quot;">​</a></h1><p>在刚刚，我们初识了代码结构</p><p>接下来使用上面的 <strong>在节点上创建脚本</strong> 方法让我们新建一个脚本，开始编写第一行代码吧</p><p>动手改改，我们试着让这个节点出生就说句话吧</p><p><strong>你可能需要用到这个方法:</strong></p><h2 id="print" tabindex="-1"><strong><code>print()</code></strong> <a class="header-anchor" href="#print" aria-label="Permalink to &quot;**`print()`**&quot;">​</a></h2><blockquote><p>● <strong><code>void print(...) vararg</code></strong></p><p>以尽可能最佳的方式将一个或多个任意类型的参数转换为字符串，并将其打印到控制台。</p><p>注意：请考虑使用 <code>push_error()</code> 和 <code>push_warning()</code> 来打印错误和警告消息，而不是 <code>print() </code>或 <code>print_rich()</code>。这将它们与用于调试目的的打印消息区分开来，同时还会在打印错误或警告时显示堆栈跟踪。另见 <code>Engine.print_to_stdout</code> 和 <strong>应用 &gt; 运行 &gt; 禁用标准输出</strong>。</p><h3 id="文档摘要-2" tabindex="-1">文档摘要 <a class="header-anchor" href="#文档摘要-2" aria-label="Permalink to &quot;文档摘要&quot;">​</a></h3><p><code>print()</code>方法可以接收任意类型的参数，用逗号间隔，参数都会被转换为字符串打印到控制台</p><p>如果你要打印文字，记得要用双引号括起来（<code>&quot;Hello!&quot;</code>）</p><p>如果你想输出错误或警告，推荐使用 <code>push_error()</code> 或 <code>push_warning()</code>，这样不仅能区分普通打印，还能显示调用栈，超级方便！</p></blockquote><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><p><img src="'+l+'" alt=""></p><p><strong>如果要打印文字，双引号一定不能忘</strong></p><p>试着点一下右上角小三角运行一下，看一下控制台</p><p><img src="'+u+'" alt=""></p><h1 id="gdscript特性" tabindex="-1">GDScript特性 <a class="header-anchor" href="#gdscript特性" aria-label="Permalink to &quot;GDScript特性&quot;">​</a></h1><h2 id="注解" tabindex="-1">注解 <a class="header-anchor" href="#注解" aria-label="Permalink to &quot;注解&quot;">​</a></h2><p>注解是 GDScript 中的一类特殊标记，用来修饰脚本或脚本中的代码，影响 Godot 引擎或编辑器对该脚本或代码所产生的效果。</p><p>注解均以 <code>@</code> 符号开头，加以注解名称而构成</p><p>比如可以将一个变量导出到编辑器中，令我们可以在编辑器中编辑它</p><p><img src="'+h+'" alt=""></p><p><img src="'+g+'" alt=""></p><h2 id="注释" tabindex="-1">注释 <a class="header-anchor" href="#注释" aria-label="Permalink to &quot;注释&quot;">​</a></h2><p><code>#</code> 之后，所在行的所有内容都会被忽略，会视为注释进行处理。</p><blockquote><p>在 Godot 的脚本编辑器中，一些特殊关键字会在注释中高亮显示以提醒用户：</p><ul><li><p><strong>关键提示</strong>*（标红）*：<code>ALERT</code>、<code>ATTENTION</code>、<code>CAUTION</code>、<code>CRITICAL</code>、<code>DANGER</code>、<code>SECURITY</code></p></li><li><p><strong>警告提示</strong>*（标黄）*：<code>BUG</code>、<code>DEPRECATED</code>、<code>FIXME</code>、<code>HACK</code>、<code>TASK</code>、<code>TBD</code>、<code>TODO</code>、<code>WARNING</code></p></li><li><p><strong>一般提示</strong>*（标绿）*：<code>INFO</code>、<code>NOTE</code>、<code>NOTICE</code>、<code>TEST</code>、<code>TESTING</code></p></li></ul><p>这些关键字均大小写敏感，故需要全大写以保证能被引擎所识别：</p><p><img src="'+_+'" alt=""></p><p>可在编辑器设置的 <strong>文本编辑器 &gt; 主题 &gt; 注释标记</strong> 部分中更改突出显示的关键字列表及其颜色。</p></blockquote><h2 id="文档注释" tabindex="-1">文档注释 <a class="header-anchor" href="#文档注释" aria-label="Permalink to &quot;文档注释&quot;">​</a></h2><p>使用两个井号（<code>##</code>）而不是一个（<code>#</code>）来添加文档注释，它将出现在脚本文档和导出变量的检查器描述中。</p><p>文档注释必须直接放在可文档项（如成员变量）的上方，或者放在文件的顶部。详见后续的 <a href="./12.doc-comments.html"><strong>文档注释</strong></a> 章节</p><p><img src="'+m+'" alt=""></p><p><img src="'+k+'" alt=""></p><h2 id="代码区块" tabindex="-1">代码区块 <a class="header-anchor" href="#代码区块" aria-label="Permalink to &quot;代码区块&quot;">​</a></h2><p>代码区块是一种特殊类型的注释，脚本编辑器将其理解为 <em>可折叠区块</em>，即在编写代码区块注释后，可以通过点击注释左侧出现的箭头来折叠和展开该区块。该箭头用一个紫色方块包围起来，以区别于标准的代码折叠。</p><p>语法如下：</p><p><img src="'+b+'" alt=""></p><h2 id="行间语句接续" tabindex="-1">行间语句接续 <a class="header-anchor" href="#行间语句接续" aria-label="Permalink to &quot;行间语句接续&quot;">​</a></h2><p>在GDScript中，一行语句可通过反斜杠（ <code>\\</code> ）接续到下一行。将反斜杠加在一行语句末尾可将该行代码与下一行代码相衔接。如：</p><p><img src="'+q+'" alt=""></p><p>可按以下方式对单个语句行进行多行接续：</p><p><img src="'+f+'" alt=""></p><p>但是这样写，可读性相对较差，不建议使用</p><h2 id="分号" tabindex="-1">分号 <a class="header-anchor" href="#分号" aria-label="Permalink to &quot;分号&quot;">​</a></h2><p>GDScript 允许你在一行中写下多条语句（赋值、函数调用以及流程控制结构等），只需要用分号 <code>;</code> 分隔就可以</p><p><img src="'+y+`" alt=""></p><p>可读性较差，不建议使用</p><p>除此之外，你也可以用<code>;</code>表示语句的结束</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h2 id="缩进语法" tabindex="-1">缩进语法 <a class="header-anchor" href="#缩进语法" aria-label="Permalink to &quot;缩进语法&quot;">​</a></h2><p>在 GDScript 中，<strong>缩进就是语法的一部分</strong>，它用来表示代码块的层级关系</p><p>缩进字符一般为空格或tab，<strong>在同一个文件中不能混着用</strong>，否则会报错：</p><blockquote><p><code>Used tab character for indentation instead of space as used before in the file.</code></p><p><em>（在文件中使用制表符作为缩进，而不是之前使用的空格。）</em></p></blockquote><p><img src="`+x+'" alt=""></p><p>在上面的代码示例中，<code>print(&quot;1&quot;)</code>和<code>print(&quot;2&quot;)</code> 缩进在 <code>if</code> 下面，所以都是属于<code>if</code>的代码块的</p><p>而<code>print(&quot;Hello, World!&quot;)</code>的缩进和 <code>if</code> 对齐，表示它<strong>不属于 <code>if</code> 的判断体</strong>，只是 <code>_ready()</code> 函数的普通一行。</p><p>所以缩进不只是为了好看，它真的真的会影响代码的运行逻辑</p><h2 id="跨语言调用" tabindex="-1">跨语言调用 <a class="header-anchor" href="#跨语言调用" aria-label="Permalink to &quot;跨语言调用&quot;">​</a></h2><p>GDScript和C#之间可以互相跨语言调用，这在使用不同语言的代码库时相当有用</p>',143)])])}const A=e(E,[["render",P]]);export{C as __pageData,A as default};
