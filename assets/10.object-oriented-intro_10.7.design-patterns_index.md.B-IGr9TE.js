import{_ as a,c as e,o as r,ag as l}from"./chunks/framework.xT_8jeIh.js";const m=JSON.parse('{"title":"设计模式","description":"","frontmatter":{},"headers":[],"relativePath":"10.object-oriented-intro/10.7.design-patterns/index.md","filePath":"10.object-oriented-intro/10.7.design-patterns/index.md"}'),i={name:"10.object-oriented-intro/10.7.design-patterns/index.md"};function p(n,t,o,h,s,c){return r(),e("div",null,[...t[0]||(t[0]=[l('<h1 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h1><p>面向对象设计模式（Object-Oriented Design Patterns）是解决软件设计中常见问题的可重用方案，它们基于面向对象编程（OOP）的核心思想（如封装、继承、多态），提供了一套经过验证的最佳实践。设计模式不是具体的代码，而是描述如何组织代码结构的模板，帮助开发者构建灵活、可维护和可扩展的软件系统。</p><blockquote><p>本章节的后续内容讲解的是传统OOP的设计模式，提供了设计模式在两种语言中的示例代码模板，若要参考在Godot游戏编程中运用这些模式的方式，请直接参见 游戏编程模式 章节</p></blockquote><hr><h3 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h3><ol><li><p>模式的目标：</p><ul><li><p>提高代码复用性，避免重复造轮子。</p></li><li><p>解耦系统组件，增强灵活性和可维护性。</p></li><li><p>提供清晰的代码结构，便于团队协作。</p></li></ul></li><li><p>四大要素：</p><ul><li><p>模式名称（如工厂模式、观察者模式）便于交流。</p></li><li><p>问题描述模式的适用场景。</p></li><li><p>解决方案描述模式的设计与实现。</p></li><li><p>效果分析模式的优缺点（如性能、复杂度）。</p></li></ul></li></ol><hr><h3 id="经典分类-gof-23种设计模式" tabindex="-1">经典分类（GoF 23种设计模式） <a class="header-anchor" href="#经典分类-gof-23种设计模式" aria-label="Permalink to &quot;经典分类（GoF 23种设计模式）&quot;">​</a></h3><p>《设计模式：可复用面向对象软件的基础》（GoF, 1994）将模式分为三类：</p><h4 id="_1-创建型模式-怎么造对象" tabindex="-1">1. <a href="./10.7.1.creational-patterns/">创建型模式（怎么造对象）</a> <a class="header-anchor" href="#_1-创建型模式-怎么造对象" aria-label="Permalink to &quot;1. [创建型模式（怎么造对象）](10.7.1.creational-patterns/)&quot;">​</a></h4><p>处理对象创建机制，解耦对象的实例化过程。</p><ul><li><p><a href="./10.7.1.creational-patterns/10.7.1.1.singleton-pattern.html">单例模式（Singleton）</a>：确保一个类只有一个实例。</p></li><li><p><a href="./10.7.1.creational-patterns/10.7.1.2.factory-method.html">工厂方法（Factory Method）</a>：由子类决定创建哪个对象。</p></li><li><p><a href="./10.7.1.creational-patterns/10.7.1.3.abstract-factory.html">抽象工厂（Abstract Factory）</a>：创建相关对象的家族。</p></li><li><p><a href="./10.7.1.creational-patterns/10.7.1.4.builder-pattern.html">建造者（Builder）</a>：分步骤构建复杂对象。</p></li><li><p><a href="./10.7.1.creational-patterns/10.7.1.5.prototype-pattern.html">原型（Prototype）</a>：通过克隆现有对象创建新对象。</p></li></ul><h4 id="_2-结构型模式-对象之间怎么组合" tabindex="-1">2. <a href="./10.7.2.structural-patterns/">结构型模式（对象之间怎么组合）</a> <a class="header-anchor" href="#_2-结构型模式-对象之间怎么组合" aria-label="Permalink to &quot;2. [结构型模式（对象之间怎么组合）](10.7.2.structural-patterns/)&quot;">​</a></h4><p>关注类和对象的组合方式，形成更大的结构。</p><ul><li><p><a href="./10.7.2.structural-patterns/10.7.2.1.adapter-pattern.html">适配器（Adapter）</a>：转换接口以兼容现有系统。</p></li><li><p><a href="./10.7.2.structural-patterns/10.7.2.3.decorator-pattern.html">装饰器（Decorator）</a>：动态添加职责。</p></li><li><p><a href="./10.7.2.structural-patterns/10.7.2.4.proxy-pattern.html">代理（Proxy）</a>：控制对对象的访问（如缓存、权限）。</p></li><li><p><a href="./10.7.2.structural-patterns/10.7.2.7.composite-pattern.html">组合（Composite）</a>：以树形结构处理部分-整体关系。</p></li><li><p><a href="./10.7.2.structural-patterns/10.7.2.5.facade-pattern.html">外观（Facade）</a>：简化复杂子系统的接口。</p></li><li><p><a href="./10.7.2.structural-patterns/10.7.2.2.bridge-pattern.html">桥接（Bridge）</a>：分离抽象与实现，避免继承爆炸。</p></li><li><p><a href="./10.7.2.structural-patterns/10.7.2.6.flyweight-pattern.html">享元（Flyweight）</a>：共享细粒度对象以减少内存占用。</p></li></ul><h4 id="_3-行为型模式-对象之间怎么说话" tabindex="-1">3. <a href="./10.7.3.behavioral-patterns/">行为型模式（对象之间怎么说话）</a> <a class="header-anchor" href="#_3-行为型模式-对象之间怎么说话" aria-label="Permalink to &quot;3. [行为型模式（对象之间怎么说话）](10.7.3.behavioral-patterns/)&quot;">​</a></h4><p>定义对象间的交互和职责分配。</p><ul><li><p><a href="./10.7.3.behavioral-patterns/10.7.3.7.observer-pattern.html">观察者（Observer）</a>：一对多的依赖通知机制。</p></li><li><p><a href="./10.7.3.behavioral-patterns/10.7.3.8.strategy-pattern.html">策略（Strategy）</a>：封装可互换的算法族。</p></li><li><p><a href="./10.7.3.behavioral-patterns/10.7.3.2.command-pattern.html">命令（Command）</a>：将请求封装为对象。</p></li><li><p><a href="./10.7.3.behavioral-patterns/10.7.3.10.template-method-pattern.html">模板方法（Template Method）</a>：定义算法骨架，子类实现步骤。</p></li><li><p><a href="./10.7.3.behavioral-patterns/10.7.3.1.chain-of-responsibility.html">责任链（Chain of Responsibility）</a>：请求沿处理链传递。</p></li><li><p><a href="./10.7.3.behavioral-patterns/10.7.3.9.state-pattern.html">状态（State）</a>：通过对象状态改变行为。</p></li><li><p><a href="./10.7.3.behavioral-patterns/10.7.3.4.iterator-pattern.html">迭代器（Iterator）</a>：提供遍历集合的统一方式。</p></li><li><p><a href="./10.7.3.behavioral-patterns/10.7.3.5.mediator-pattern.html">中介者（Mediator）</a>：集中管理对象间通信。</p></li><li><p><a href="./10.7.3.behavioral-patterns/10.7.3.6.memento-pattern.html">备忘录（Memento）</a>：保存和恢复对象状态。</p></li><li><p><a href="./10.7.3.behavioral-patterns/10.7.3.11.visitor-pattern.html">访问者（Visitor）</a>：在不修改类的情况下添加操作。</p></li><li><p><a href="./10.7.3.behavioral-patterns/10.7.3.3.interpreter-pattern.html">解释器（Interpreter）</a>：为语言语法定义解释器（较少使用）。</p></li></ul>',18)])])}const u=a(i,[["render",p]]);export{m as __pageData,u as default};
