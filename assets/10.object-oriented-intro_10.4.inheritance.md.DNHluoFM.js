import{_ as i,c as a,o as n,ag as e}from"./chunks/framework.xT_8jeIh.js";const c=JSON.parse('{"title":"继承","description":"","frontmatter":{},"headers":[],"relativePath":"10.object-oriented-intro/10.4.inheritance.md","filePath":"10.object-oriented-intro/10.4.inheritance.md"}'),p={name:"10.object-oriented-intro/10.4.inheritance.md"};function t(h,s,l,k,d,r){return n(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h1><p>继承的基本思想是基于对某个基类的扩展，制定出一个新的派生类，派生类可以继承基类所有的属性和方法，也可以增加基类所不具备的属性和方法，或者重写基类中的方法</p><p>在 GDScript 中，一个类可以继承自：</p><ul><li><p>全局类（如 <code>Node</code>, <code>Resource</code>, <code>CharacterBody2D</code> 等等）</p></li><li><p>另一个类文件（直接用路径字符串）</p></li><li><p>某个类文件中的内部类</p></li></ul><p><strong>不允许多重继承</strong>（继承多个类）</p><p>继承使用<code>extends</code>关键字，如果没有显式指定继承的类，则该类默认继承自<code>RefCounted</code>，所以在一些情况下可以不写 <code>extends</code></p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeClass</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 继承一个全局类</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extends</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;somefile.gd&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 继承某个无名类</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extends</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;somefile.gd&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SomeInnerClass</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 继承某个无名类的内部类</span></span></code></pre></div><p>继承之后，该类就能直接访问父类的所有成员。</p><p>你自然也能在声明全局类/内部类的同时继承某一类，<strong><code>class_name</code>或<code>extends</code>必须写在代码文件首行！</strong></p><p><code>extends</code>和<code>class_name</code>既可以写在同一行，也可以写成两行，但都必须位于脚本文件开头！</p><p>而<code>class</code>和<code>extends</code>必须写在同一行！</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class_name</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Player</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CharacterBody2D</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    pass</span></span></code></pre></div><p><strong>子类中不可以声明和父类同名但参数不同的方法（构造函数除外），也不能声明与父类同名的属性（不论方法或属性是不是静态的）</strong></p><p><strong>可以使用<code>is</code>运算符来检查给定的实例是否继承自某个类</strong></p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># item.gd</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class_name</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Resource</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># sword.gd</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class_name</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sword</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Item</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># main.gd</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Node</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _ready</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Item</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sword </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sword</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sword </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sword </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sword </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># false</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Sword</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># false</span></span></code></pre></div><h2 id="我应该继承哪个类" tabindex="-1">我应该继承哪个类？ <a class="header-anchor" href="#我应该继承哪个类" aria-label="Permalink to &quot;我应该继承哪个类？&quot;">​</a></h2><p>在 GDScript 中，如果不显式写 <code>extends</code>，脚本默认继承自 <code>RefCounted</code>，这是最常用的基类之一，因为它自动进行引用计数，无需手动管理内存。</p><p>什么时候选什么类？看这里</p><ul><li><p><strong>需要与场景树交互时</strong>：继承 <code>Node</code> 或其子类。它们能加入场景树，参与场景树生命周期（如 <code>_ready</code>、<code>_process</code>）以及信号系统。</p></li><li><p><strong>仅作为数据结构或对象容器时</strong>：使用 <code>RefCounted</code>。它适合脚本逻辑、纯数据处理，不需要场景绑定。</p></li><li><p><strong>如果是可以保存到磁盘的资源对象（如配置、技能表、数据模板）</strong>：考虑继承 <code>Resource</code>，这样可以轻松保存为 <code>.tres</code> 或 <code>.res</code> 文件。</p></li><li><p><strong>如果你需要创建更底层、精细控制内存的数据结构，Godot 现有的类都不合适</strong>：可以继承 <code>Object</code>，但你需要自己处理内存释放和生命周期，开发上更高级也更危险！</p></li></ul><h1 id="重写-override-与super关键字" tabindex="-1">重写（override）与super关键字 <a class="header-anchor" href="#重写-override-与super关键字" aria-label="Permalink to &quot;重写（override）与super关键字&quot;">​</a></h1><p>当你在子类中定义了和父类<strong>相同签名</strong>的方法时，会自动<strong>覆盖</strong>父类的方法。</p><p><strong>这时在这个类的实例上调用这个方法时就会使用重写的逻辑，而不是父类的逻辑</strong></p><p>如果你还想在重写时<strong>调用父类的逻辑</strong>，可以使用 <code>super</code>：</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> some_func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x):</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 调用父类中同名的 some_func 方法</span></span></code></pre></div><p><strong>隐式<code>super</code>调用</strong>（<code>super(...)</code>）只能写在方法中，它会调用基类中的同名方法，隐式<code>super</code>所在的方法必须也在基类中有被定义，也需要在<code>super</code>的括号内传入必要的参数</p><p>也可以使用 <strong>显式 <code>super</code>调用</strong> 来访问指定方法，可在 <code>super</code> 关键字后用英文句点连接父类方法名（带括号）：</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> overriding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 这会覆盖父类的方法</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dont_override</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> super</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">overriding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 这将调用父类中定义的方法</span></span></code></pre></div><p><strong>同样，你也无法在静态方法中调用父类的实例方法</strong></p><h1 id="继承中的构造函数" tabindex="-1">继承中的构造函数 <a class="header-anchor" href="#继承中的构造函数" aria-label="Permalink to &quot;继承中的构造函数&quot;">​</a></h1><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># state.gd</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class_name</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> State</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entity : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    enetity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> set_message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(msg: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># idle.gd</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class_name</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IdleState</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> State</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, m: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m</span></span></code></pre></div><p>在GDScript中，<strong>若父类定义了有参数的构造函数，子类也会继承该构造函数</strong></p><p>如果子类没有显式声明构造函数，则创建实例时会使用父类构造函数，静态构造函数也是如此，否则使用子类重写的逻辑</p><p>子类可以具有和父类不同参数的构造函数，你可以使用隐式<code>super</code>调用，调用父类构造函数并传递所需的参数</p><p>如果你需要子类的初始化逻辑与父类不同，你可以不在构造函数中调用父类的构造函数，但你也应当确保父类的必要成员能够被初始化</p><h1 id="练习" tabindex="-1">练习 <a class="header-anchor" href="#练习" aria-label="Permalink to &quot;练习&quot;">​</a></h1><ol><li><p>请创建一个类 <code>Animal</code>，它包含一个 <code>name</code> 字段和一个空实现的 <code>speak()</code> 方法，再创建一个类 <code>Cat</code> 继承自 <code>Animal</code>，并添加一个新字段 <code>fur_color</code>。</p></li><li><p>基于上面的 <code>Animal</code> 类，在 <code>Cat</code> 类中重写基类的 <code>speak()</code> 方法，使它输出 <code>&quot;Meow!&quot;</code></p></li><li><p>在 <code>Animal</code> 类中加入带参数的 <code>_init(name: String)</code> 构造函数， 然后在 <code>Cat</code> 中定义自己的 <code>_init(name: String, fur_color: String)</code>，调用 <code>super(name)</code> 来初始化 <code>name</code> 字段。</p></li></ol>`,36)])])}const g=i(p,[["render",t]]);export{c as __pageData,g as default};
