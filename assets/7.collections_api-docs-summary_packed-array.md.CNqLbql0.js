import{_ as a,c as o,o as t,ag as r}from"./chunks/framework.xT_8jeIh.js";const p=JSON.parse('{"title":"紧缩数组方法 API文档摘要","description":"","frontmatter":{},"headers":[],"relativePath":"7.collections/api-docs-summary/packed-array.md","filePath":"7.collections/api-docs-summary/packed-array.md"}'),d={name:"7.collections/api-docs-summary/packed-array.md"};function i(l,e,c,n,h,s){return t(),o("div",null,[...e[0]||(e[0]=[r('<h1 id="紧缩数组方法-api文档摘要" tabindex="-1">紧缩数组方法 API文档摘要 <a class="header-anchor" href="#紧缩数组方法-api文档摘要" aria-label="Permalink to &quot;紧缩数组方法 API文档摘要&quot;">​</a></h1><p>紧缩数组除字节数组<code>PackedByteArray</code>外，都有22个功能相同、签名相似的方法</p><h1 id="非字节数组通用方法" tabindex="-1">非字节数组通用方法 <a class="header-anchor" href="#非字节数组通用方法" aria-label="Permalink to &quot;非字节数组通用方法&quot;">​</a></h1><h1 id="bool-append-value-float-int-vector2" tabindex="-1"><code>bool append(value: float / int / Vector2 ...)</code> <a class="header-anchor" href="#bool-append-value-float-int-vector2" aria-label="Permalink to &quot;`bool append(value: float / int / Vector2 ...)`&quot;">​</a></h1><h3 id="参数说明" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><strong><code>value</code></strong>：要追加的元素，类型应和该 <code>Packed</code> 数组对应（如 <code>float</code>、<code>int</code>、<code>String</code>、<code>Vector2</code> 等）</li></ul><hr><h3 id="方法说明" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>向数组末尾追加一个元素(<code>push_back()</code>的别名)</p><hr><h3 id="返回值" tabindex="-1">返回值 <a class="header-anchor" href="#返回值" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>是否成功追加，返回 <code>true</code> 或 <code>false</code></p><h1 id="void-append-array-array-packedint32array-packedfloat32array" tabindex="-1"><code>void append_array(array: PackedInt32Array / PackedFloat32Array ...)</code> <a class="header-anchor" href="#void-append-array-array-packedint32array-packedfloat32array" aria-label="Permalink to &quot;`void append_array(array: PackedInt32Array / PackedFloat32Array ...)`&quot;">​</a></h1><h3 id="参数说明-1" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-1" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><strong><code>array</code></strong>: 另一个同类型的 Packed 紧缩数组，将被整体追加到当前数组末尾。</li></ul><hr><h3 id="方法说明-1" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-1" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>将传入的数组内容整体追加到当前数组后方，性能优于使用<code>+=</code>运算符拼接数组</p><h1 id="int-bsearch-value-int-float-vector2-before-bool-true" tabindex="-1"><code>int bsearch(value: int / float / Vector2 / ..., before: bool = true)</code> <a class="header-anchor" href="#int-bsearch-value-int-float-vector2-before-bool-true" aria-label="Permalink to &quot;`int bsearch(value: int / float / Vector2 / ..., before: bool = true)`&quot;">​</a></h1><h3 id="参数说明-2" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-2" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><p><strong><code>value</code></strong>：要查找的目标值，类型应与数组匹配</p></li><li><p><strong><code>before</code></strong>（可选）：默认为 <code>true</code>。如果为 <code>true</code>，返回的索引指示元素会插在所有等于 <code>value</code> 的元素之前；否则插在之后。</p></li></ul><hr><h3 id="方法说明-2" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-2" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>使用<strong>二分查找</strong>在排序好的数组中查找目标值的位置：</p><ul><li><p>如果找到，返回其索引</p></li><li><p>如果没找到，返回可插入该值以维持排序的位置</p></li></ul><p>若数组未排序，则结果不可预期</p><p>对于三个向量类型和两个浮点数类型的紧缩数组，如果数组中包含NaN，则这个方法的结果可能不准确。</p><hr><h3 id="返回值-1" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-1" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>目标值在数组中的索引，或应插入的位置</p><h1 id="void-clear" tabindex="-1"><strong><code>void clear()</code></strong> <a class="header-anchor" href="#void-clear" aria-label="Permalink to &quot;**`void clear()`**&quot;">​</a></h1><h3 id="方法说明-3" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-3" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>清空数组，相当于 <code>resize(0)</code></p><h1 id="int-count-value-int-float-vector2" tabindex="-1"><strong><code>int count(value: int / float / Vector2 / ...)</code></strong> <a class="header-anchor" href="#int-count-value-int-float-vector2" aria-label="Permalink to &quot;**`int count(value: int / float / Vector2 / ...)`**&quot;">​</a></h1><h3 id="参数说明-3" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-3" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><strong><code>value</code></strong>：要统计出现次数的值，需与数组元素类型一致</li></ul><hr><h3 id="方法说明-4" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-4" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>统计数组中 <code>value</code> 出现了多少次</p><p>对于三个向量类型和两个浮点数类型的紧缩数组，如果数组中包含NaN，则这个方法的结果可能不准确。</p><hr><h3 id="返回值-2" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-2" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>一个整数，表示目标值的出现次数</p><h1 id="packedint32array-packedfloat32array-duplicate" tabindex="-1"><strong><code>PackedInt32Array / PackedFloat32Array / ... duplicate()</code></strong> <a class="header-anchor" href="#packedint32array-packedfloat32array-duplicate" aria-label="Permalink to &quot;**`PackedInt32Array / PackedFloat32Array / ... duplicate()`**&quot;">​</a></h1><h3 id="方法说明-5" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-5" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>拷贝一份该数组的副本</p><p>新数组与原数组内容相同，但为不同实例，彼此独立</p><h3 id="返回值-3" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-3" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>该数组的副本</p><h1 id="void-fill-value-int-float-vector2" tabindex="-1"><strong><code>void fill(value: int / float / Vector2 / ...)</code></strong> <a class="header-anchor" href="#void-fill-value-int-float-vector2" aria-label="Permalink to &quot;**`void fill(value: int / float / Vector2 / ...)`**&quot;">​</a></h1><h3 id="参数说明-4" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-4" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><strong><code>value</code></strong>：填充用的值，应与数组类型一致</li></ul><hr><h3 id="方法说明-6" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-6" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>把数组里的<strong>每个元素都变成同一个值，</strong> 适合配合 <code>resize()</code> 一起使用</p><p>对于三个向量类型和两个浮点数类型的紧缩数组，如果数组中包含NaN，则这个方法的结果可能不准确。</p><h1 id="int-find-value-int-float-vector2-from-int-0" tabindex="-1"><strong><code>int find(value: int / float / Vector2 / ..., from: int = 0)</code></strong> <a class="header-anchor" href="#int-find-value-int-float-vector2-from-int-0" aria-label="Permalink to &quot;**`int find(value: int / float / Vector2 / ..., from: int = 0)`**&quot;">​</a></h1><h3 id="参数说明-5" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-5" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><p><strong><code>value</code></strong>：要查找的元素</p></li><li><p><strong><code>from</code></strong>（可选）：起始查找位置，默认是数组开头</p></li></ul><hr><h3 id="方法说明-7" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-7" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>查找 <code>value</code> 在数组中的首次出现位置 如果没找到，就返回 <code>-1</code></p><p>对于三个向量类型和两个浮点数类型的紧缩数组，如果数组中包含NaN，则这个方法的结果可能不准确。</p><hr><h3 id="返回值-4" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-4" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>元素首次出现的索引，或 -1（表示未找到）</p><h1 id="int-get-index-int" tabindex="-1"><strong><code>int get(index: int)</code></strong> <a class="header-anchor" href="#int-get-index-int" aria-label="Permalink to &quot;**`int get(index: int)`**&quot;">​</a></h1><h3 id="参数说明-6" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-6" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><strong><code>index</code></strong>：目标索引位置</li></ul><hr><h3 id="方法说明-8" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-8" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>返回数组中指定位置的元素，等同于 <code>array[index]</code> 的效果</p><hr><h3 id="返回值-5" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-5" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>对应索引处的值</p><h1 id="bool-has-value-int-float-vector2" tabindex="-1"><strong><code>bool has(value: int / float / Vector2 / ...)</code></strong> <a class="header-anchor" href="#bool-has-value-int-float-vector2" aria-label="Permalink to &quot;**`bool has(value: int / float / Vector2 / ...)`**&quot;">​</a></h1><h3 id="参数说明-7" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-7" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><strong><code>value</code></strong>：要查找的值，类型需与数组一致</li></ul><hr><h3 id="方法说明-9" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-9" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>判断数组中是否<strong>包含某个值</strong>，有就返回 <code>true</code>，否则返回 <code>false</code></p><p>也可以用 <code>in</code> 运算符来写更简洁的语法</p><p>对于三个向量类型和两个浮点数类型的紧缩数组，如果数组中包含NaN，则这个方法的结果可能不准确。</p><hr><h3 id="返回值-6" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-6" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>一个布尔值，指示值是否存在于数组中，存在则返回<code>true</code>，否则为<code>false</code></p><h1 id="int-insert-at-index-int-value-int-float-vector2" tabindex="-1"><strong><code>int insert(at_index: int, value: int / float / Vector2 / ...)</code></strong> <a class="header-anchor" href="#int-insert-at-index-int-value-int-float-vector2" aria-label="Permalink to &quot;**`int insert(at_index: int, value: int / float / Vector2 / ...)`**&quot;">​</a></h1><h3 id="参数说明-8" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-8" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><p><strong><code>at_index</code></strong>：插入的位置（0 到数组末尾之间）</p></li><li><p><strong><code>value</code></strong>：要插入的值</p></li></ul><hr><h3 id="方法说明-10" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-10" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>在数组指定位置插入新元素</p><p>之后的元素都会整体往后挪动一个位置。</p><hr><h3 id="返回值-7" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-7" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>如果插入成功，返回 <code>OK</code>；失败时返回对应错误码</p><h1 id="bool-is-empty-const" tabindex="-1"><strong><code>bool is_empty() const</code></strong> <a class="header-anchor" href="#bool-is-empty-const" aria-label="Permalink to &quot;**`bool is_empty() const`**&quot;">​</a></h1><h3 id="方法说明-11" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-11" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>判断数组是否为空</p><hr><h3 id="返回值-8" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-8" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>如果数组为空返回<code>true</code>，否则返回<code>false</code></p><h1 id="bool-push-back-value-int-float-vector2" tabindex="-1"><strong><code>bool push_back(value: int / float / Vector2 / ...)</code></strong> <a class="header-anchor" href="#bool-push-back-value-int-float-vector2" aria-label="Permalink to &quot;**`bool push_back(value: int / float / Vector2 / ...)`**&quot;">​</a></h1><h3 id="参数说明-9" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-9" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><strong><code>value</code></strong>：要添加的元素，需与数组类型一致</li></ul><hr><h3 id="方法说明-12" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-12" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>把一个元素追加到数组的末尾</p><p>是 <code>append()</code> 的另一个名字</p><hr><h3 id="返回值-9" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-9" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>返回一个布尔值，指示是否成功添加元素</p><h1 id="void-remove-at-index-int" tabindex="-1"><strong><code>void remove_at(index: int)</code></strong> <a class="header-anchor" href="#void-remove-at-index-int" aria-label="Permalink to &quot;**`void remove_at(index: int)`**&quot;">​</a></h1><h3 id="参数说明-10" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-10" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><strong><code>index</code></strong>：要移除的元素位置（不能为负数）</li></ul><hr><h3 id="方法说明-13" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-13" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>移除数组中指定位置的元素，后面的元素都会整体前移一位</p><h1 id="int-resize-new-size-int" tabindex="-1"><strong><code>int resize(new_size: int)</code></strong> <a class="header-anchor" href="#int-resize-new-size-int" aria-label="Permalink to &quot;**`int resize(new_size: int)`**&quot;">​</a></h1><h3 id="参数说明-11" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-11" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><strong><code>new_size</code></strong>：要设定的新长度</li></ul><hr><h3 id="方法说明-14" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-14" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>更改数组大小</p><ul><li><p>增大时自动填充数组类型的默认值</p></li><li><p>缩小时从尾部截断</p></li></ul><p>效率比逐个 <code>push_back()</code> 高得多</p><hr><h3 id="返回值-10" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-10" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>如果成功，返回 <code>OK</code>；失败时返回对应错误码</p><h1 id="void-reverse" tabindex="-1"><strong><code>void reverse()</code></strong> <a class="header-anchor" href="#void-reverse" aria-label="Permalink to &quot;**`void reverse()`**&quot;">​</a></h1><h3 id="方法说明-15" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-15" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>把数组中的元素顺序整个翻转，前变后、后变前</p><h1 id="int-rfind-value-int-float-vector2-from-int-1" tabindex="-1"><strong><code>int rfind(value: int / float / Vector2 / ..., from: int = -1)</code></strong> <a class="header-anchor" href="#int-rfind-value-int-float-vector2-from-int-1" aria-label="Permalink to &quot;**`int rfind(value: int / float / Vector2 / ..., from: int = -1)`**&quot;">​</a></h1><h3 id="参数说明-12" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-12" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><p><strong><code>value</code></strong>：要找的目标值</p></li><li><p><strong><code>from</code></strong>（可选）：从哪个索引开始往前查找，默认为数组末尾，如果为负数则被视为相对于数组的结尾。</p></li></ul><hr><h3 id="方法说明-16" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-16" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>从后往前找某个值在数组中<strong>最后一次出现的位置</strong> 找不到就返回 <code>-1</code></p><p>对于三个向量类型和两个浮点数类型的紧缩数组，如果数组中包含NaN，则这个方法的结果可能不准确。</p><hr><h3 id="返回值-11" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-11" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>目标值最后一次出现的索引，如果没找到则返回<code>-1</code></p><h1 id="void-set-index-int-value-int-float-vector2" tabindex="-1"><strong><code>void set(index: int, value: int / float / Vector2 / ...)</code></strong> <a class="header-anchor" href="#void-set-index-int-value-int-float-vector2" aria-label="Permalink to &quot;**`void set(index: int, value: int / float / Vector2 / ...)`**&quot;">​</a></h1><h3 id="参数说明-13" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-13" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><p><strong><code>index</code></strong>：要修改的目标位置</p></li><li><p><strong><code>value</code></strong>：要设置的新值，类型需匹配数组元素类型</p></li></ul><hr><h3 id="方法说明-17" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-17" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>设置指定位置的元素为新值 和 <code>array[index] = value</code> 一样的效果</p><h1 id="int-size-const" tabindex="-1"><strong><code>int size() const</code></strong> <a class="header-anchor" href="#int-size-const" aria-label="Permalink to &quot;**`int size() const`**&quot;">​</a></h1><h3 id="方法说明-18" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-18" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>获取数组当前的长度</p><hr><h3 id="返回值-12" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-12" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>一个整数，表示数组当前的长度</p><h1 id="packedint32array-packedfloat32array-slice-begin-int-end-int-0x7fffffff-const" tabindex="-1"><strong><code>PackedInt32Array / PackedFloat32Array / ... slice(begin: int, end: int = 0x7FFFFFFF) const</code></strong> <a class="header-anchor" href="#packedint32array-packedfloat32array-slice-begin-int-end-int-0x7fffffff-const" aria-label="Permalink to &quot;**`PackedInt32Array / PackedFloat32Array / ... slice(begin: int, end: int = 0x7FFFFFFF) const`**&quot;">​</a></h1><h3 id="参数说明-14" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-14" aria-label="Permalink to &quot;参数说明&quot;">​</a></h3><ul><li><p><strong><code>begin</code></strong>：起始索引（包含）</p></li><li><p><strong><code>end</code></strong>（可选）：结束索引（不包含），默认会切到数组末尾</p></li></ul><hr><h3 id="方法说明-19" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-19" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>返回从 <code>begin</code> 到 <code>end</code> 之间的<strong>新数组切片</strong>～不影响原数组本体。</p><p>支持负索引（表示从尾部数起），非常灵活方便</p><p>例如 <code>arr.slice(1)</code> 等同于 <code>arr.slice(1, arr.size())</code> ，<code>arr.slice(0, -2)</code>等同于<code>arr.slice(0, arr.size() - 2)</code></p><hr><h3 id="返回值-13" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-13" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>一个新的 PackedArray，包含所选范围的元素</p><h1 id="void-sort" tabindex="-1"><strong><code>void sort()</code></strong> <a class="header-anchor" href="#void-sort" aria-label="Permalink to &quot;**`void sort()`**&quot;">​</a></h1><h3 id="方法说明-20" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-20" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>将数组中的元素按升序排列</p><p>使用内置比较规则（即“小于”关系），较小的值在前，较大的值在后</p><p>对于三个向量类型和两个浮点数类型的紧缩数组，如果数组中包含NaN，则这个方法的结果可能不准确。</p><h1 id="packedbytearray-to-byte-array-const" tabindex="-1"><strong><code>PackedByteArray to_byte_array() const</code></strong> <a class="header-anchor" href="#packedbytearray-to-byte-array-const" aria-label="Permalink to &quot;**`PackedByteArray to_byte_array() const`**&quot;">​</a></h1><h3 id="方法说明-21" tabindex="-1">方法说明 <a class="header-anchor" href="#方法说明-21" aria-label="Permalink to &quot;方法说明&quot;">​</a></h3><p>将当前 <code>PackedArray</code>转换为字节数组（<code>PackedByteArray</code>），不同类型的元素将按照<strong>特定的方式编码为字节序列</strong>。 返回的新数组不修改原数组，适合序列化、保存或网络传输等用途</p><p><strong>字节数组<code>PackedByteArray</code>不具备该方法</strong></p><hr><h3 id="编码差异说明" tabindex="-1">编码差异说明 <a class="header-anchor" href="#编码差异说明" aria-label="Permalink to &quot;编码差异说明&quot;">​</a></h3><table tabindex="0"><thead><tr><th>原始类型</th><th>每元素编码字节数</th><th>编码格式说明</th></tr></thead><tbody><tr><td>PackedInt32Array</td><td>4 字节</td><td>每个整数以 32 位（4 字节）形式编码</td></tr><tr><td>PackedInt64Array</td><td>8 字节</td><td>每个整数以 64 位（8 字节）形式编码</td></tr><tr><td>PackedFloat32Array</td><td>4 字节</td><td>每个浮点数以 IEEE 754 单精度编码</td></tr><tr><td>PackedFloat64Array</td><td>8 字节</td><td>每个浮点数以 IEEE 754 双精度编码</td></tr><tr><td>PackedColorArray</td><td>4 字节 × 4 通道</td><td>每个颜色的 R/G/B/A 通道分别编码为 4 字节</td></tr><tr><td>PackedVector2Array / Vector3Array / Vector4Array</td><td>4 字节 × 每个分量</td><td>每个 float 分量编码为 4 字节，依次存储</td></tr><tr><td>PackedStringArray</td><td>不定长度</td><td>每个字符串以 UTF-8 编码，并追加一个 null 字节结尾</td></tr></tbody></table><p>字符串结尾会追加一个<code>null</code>字节作为结尾标记，例如：<code>&quot;Hello&quot; → [72, 101, 108, 108, 111, 0]</code></p><p>多出来的 <code>0</code>（null 字节）就是结尾标记，表示字符串结束</p><p>编码后的字节数组长度就是原始数组长度乘字节数，例如:</p><p>int32数组编码后的长度为：<code>int32_arr.size() * 4</code></p><p>float64数组编码后的长度为：<code>float64_arr.size() * 8</code></p><p>由于字符串数组中每个字符串因不同的语言和内容，字节长度都不一定一致，因此不能使用上面的方法计算</p><hr><h3 id="返回值-14" tabindex="-1">返回值 <a class="header-anchor" href="#返回值-14" aria-label="Permalink to &quot;返回值&quot;">​</a></h3><p>一个新的 <code>PackedByteArray</code>，包含对应编码后的字节数据</p><h1 id="字节数组特有方法" tabindex="-1">字节数组特有方法 <a class="header-anchor" href="#字节数组特有方法" aria-label="Permalink to &quot;字节数组特有方法&quot;">​</a></h1><p>字节数组包含非字节数组所拥有的除去<code>to_byte_array()</code>外的所有21个通用方法，同时也提供了将各种类型编码为字节或从字节解码的方法</p><h3 id="数据压缩-解压相关" tabindex="-1">数据压缩 / 解压相关 <a class="header-anchor" href="#数据压缩-解压相关" aria-label="Permalink to &quot;数据压缩 / 解压相关&quot;">​</a></h3><ul><li><p><code>compress(compression_mode: int = 0)</code> 使用指定压缩模式(<code>FileAccess.CompressionMode</code>) 压缩数据，返回新的 PackedByteArray。</p></li><li><p><code>decompress(buffer_size: int, compression_mode: int = 0)</code> 解压数据，需提供预估的解压后大小 <code>buffer_size</code>，返回新的 PackedByteArray。</p></li><li><p><code>decompress_dynamic(max_output_size: int, compression_mode: int = 0)</code> 解压数据，无需提前知道大小，但允许设置最大解压限制，<code>-1</code>表示不限制，压缩模式只支持 <code>brotli</code>/<code>gzip</code>/<code>deflate</code>，返回新的 PackedByteArray。</p></li></ul><h3 id="数据解码-decode" tabindex="-1">数据解码（decode） <a class="header-anchor" href="#数据解码-decode" aria-label="Permalink to &quot;数据解码（decode）&quot;">​</a></h3><p>所有 <code>decode_*()</code> 方法都从指定的字节偏移处读取对应类型的值。</p><p>字节数不足时，读取失败则返回<code>0.0</code>或<code>null</code></p><h4 id="浮点数" tabindex="-1">浮点数： <a class="header-anchor" href="#浮点数" aria-label="Permalink to &quot;浮点数：&quot;">​</a></h4><ul><li><p><code>decode_half(offset)</code>：解码 16 位 float（半精度）</p></li><li><p><code>decode_float(offset)</code>：解码 32 位 float（单精度）</p></li><li><p><code>decode_double(offset)</code>：解码 64 位 float（双精度）</p></li></ul><h4 id="有符号整数" tabindex="-1">有符号整数： <a class="header-anchor" href="#有符号整数" aria-label="Permalink to &quot;有符号整数：&quot;">​</a></h4><ul><li><p><code>decode_s8(offset)</code>：解码 8 位有符号整数</p></li><li><p><code>decode_s16(offset)</code>：解码 16 位有符号整数</p></li><li><p><code>decode_s32(offset)</code>：解码 32 位有符号整数</p></li><li><p><code>decode_s64(offset)</code>：解码 64 位有符号整数</p></li></ul><h4 id="无符号整数" tabindex="-1">无符号整数： <a class="header-anchor" href="#无符号整数" aria-label="Permalink to &quot;无符号整数：&quot;">​</a></h4><ul><li><p><code>decode_u8(offset)</code>：解码 8 位无符号整数</p></li><li><p><code>decode_u16(offset)</code>：解码 16 位无符号整数</p></li><li><p><code>decode_u32(offset)</code>：解码 32 位无符号整数</p></li><li><p><code>decode_u64(offset)</code>：解码 64 位无符号整数</p></li></ul><h4 id="variant-解码" tabindex="-1">Variant 解码 <a class="header-anchor" href="#variant-解码" aria-label="Permalink to &quot;Variant 解码&quot;">​</a></h4><ul><li><p><code>decode_var(offset, allow_objects = false)</code> 从偏移位置解码一个 Variant，支持复杂类型，可选是否允许 <code>Object</code> 类型，当数据是派生自<code>Object</code>的类型而<code>allow_objects</code>为<code>false</code>时，则返回<code>null</code>。</p></li><li><p><code>decode_var_size(offset, allow_objects = false)</code> 获取从偏移位置开始的 Variant 数据所占的字节大小。要求起始位置后至少有 4 个字节的数据，否则会失败。</p></li></ul><h3 id="编码方法-encode" tabindex="-1">编码方法（encode） <a class="header-anchor" href="#编码方法-encode" aria-label="Permalink to &quot;编码方法（encode）&quot;">​</a></h3><p>这些方法会将数值编码成二进制字节写入数组，从 <code>byte_offset</code> 开始，必须保证数组已有足够的空间！</p><h4 id="浮点数编码" tabindex="-1">浮点数编码 <a class="header-anchor" href="#浮点数编码" aria-label="Permalink to &quot;浮点数编码&quot;">​</a></h4><ul><li><p><code>encode_half(offset, value)</code>：将 float 编码为 16 位（2 字节）</p></li><li><p><code>encode_float(offset, value)</code>：将 float 编码为 32 位（4 字节）</p></li><li><p><code>encode_double(offset, value)</code>：将 float 编码为 64 位（8 字节）</p></li></ul><h4 id="有符号整数编码" tabindex="-1">有符号整数编码 <a class="header-anchor" href="#有符号整数编码" aria-label="Permalink to &quot;有符号整数编码&quot;">​</a></h4><ul><li><p><code>encode_s8(offset, value)</code>：8 位（1 字节）</p></li><li><p><code>encode_s16(offset, value)</code>：16 位（2 字节）</p></li><li><p><code>encode_s32(offset, value)</code>：32 位（4 字节）</p></li><li><p><code>encode_s64(offset, value)</code>：64 位（8 字节）</p></li></ul><h4 id="无符号整数编码" tabindex="-1">无符号整数编码 <a class="header-anchor" href="#无符号整数编码" aria-label="Permalink to &quot;无符号整数编码&quot;">​</a></h4><ul><li><p><code>encode_u8(offset, value)</code>：8 位（1 字节）</p></li><li><p><code>encode_u16(offset, value)</code>：16 位（2 字节）</p></li><li><p><code>encode_u32(offset, value)</code>：32 位（4 字节）</p></li><li><p><code>encode_u64(offset, value)</code>：64 位（8 字节）</p></li></ul><h4 id="variant-编码" tabindex="-1">Variant 编码 <a class="header-anchor" href="#variant-编码" aria-label="Permalink to &quot;Variant 编码&quot;">​</a></h4><ul><li><code>encode_var(offset, value, allow_objects = false)</code> 将 <code>Variant </code>编码为字节数据，返回写入的字节数。支持大部分类型，如果禁止<code>Object</code>序列化，即<code>allow_objects</code>为<code>false</code>，则只会将其ID进行序列化</li></ul><h3 id="从字节数组还原到字符串" tabindex="-1">从字节数组还原到字符串 <a class="header-anchor" href="#从字节数组还原到字符串" aria-label="Permalink to &quot;从字节数组还原到字符串&quot;">​</a></h3><ul><li><p><code>get_string_from_ascii()</code> 按照 <strong>ASCII/Latin-1</strong> 解码每个字节为字符，速度快但不支持多字节字符；适合内容全是英文或老式西文编码（是 <code>String.to_ascii_buffer()</code> 的逆运算）。</p></li><li><p><code>get_string_from_utf8()</code> 按照 <strong>UTF-8</strong> 解码，支持全球语言字符；解析用户输入建议优先使用它（是 <code>String.to_utf8_buffer()</code> 的逆运算）。</p></li><li><p><code>get_string_from_utf16()</code> 按照 <strong>UTF-16</strong> 解码，需注意字节序问题（有 BOM 自动识别，否则按系统默认）；是 <code>String.to_utf16_buffer()</code> 的逆运算。</p></li><li><p><code>get_string_from_utf32()</code> 按照 <strong>UTF-32</strong> 解码，同样依赖字节序；是 <code>String.to_utf32_buffer()</code> 的逆运算。</p></li><li><p><code>get_string_from_wchar()</code> 按照 <strong>宽字符编码</strong>（Windows 上为 UTF-16，其他平台为 UTF-32）解码，跨平台时要留意平台差异；是 <code>String.to_wchar_buffer()</code> 的逆运算。</p></li></ul><h4 id="该用哪一个" tabindex="-1">该用哪一个？ <a class="header-anchor" href="#该用哪一个" aria-label="Permalink to &quot;该用哪一个？&quot;">​</a></h4><ul><li><p>不确定来源、要万无一失：用 <code>get_string_from_utf8()</code></p></li><li><p>肯定全是英文/Latin-1：可以考虑 <code>get_string_from_ascii()</code>，快一些</p></li><li><p>与平台 API、C/C++ 交互：考虑 <code>wchar</code>、<code>utf16</code>、<code>utf32</code></p></li><li><p>和你用 <code>String.to_*_buffer()</code> 的配对原则就是 —— “谁转的，就找谁还原”</p></li></ul><h3 id="类型转换-byte-→-packedxxxarray" tabindex="-1">类型转换：Byte → PackedXXXArray <a class="header-anchor" href="#类型转换-byte-→-packedxxxarray" aria-label="Permalink to &quot;类型转换：Byte → PackedXXXArray&quot;">​</a></h3><p>这些方法会把 <code>PackedByteArray</code> 转换成对应类型的紧缩数组，原理就是按照固定字节块大小（按类型）来“切片重组”</p><p>输入数据如果不是合法的对应格式，长度不一致会返回空数组并报错，数据不合法则对应元素会转换为默认值<code>0.0</code></p><ul><li><p><code>to_float32_array()</code>：每 4 字节 → 一个 float（32 位浮点数），大小需是 4 的倍数。</p></li><li><p><code>to_float64_array()</code>：每 8 字节 → 一个 double（64 位浮点数），大小需是 8 的倍数。</p></li><li><p><code>to_int32_array()</code>：每 4 字节 → 一个 int32，大小需是 4 的倍数。</p></li><li><p><code>to_int64_array()</code>：每 8 字节 → 一个 int64，大小需是 8 的倍数</p></li><li><p><code>to_color_array()</code></p></li><li><p><code>to_vector2_array()</code>/<code>to_vector3_array</code>/<code>to_vector4_array</code></p></li></ul><h3 id="其他实用方法-bytearray-专属" tabindex="-1">其他实用方法（ByteArray 专属） <a class="header-anchor" href="#其他实用方法-bytearray-专属" aria-label="Permalink to &quot;其他实用方法（ByteArray 专属）&quot;">​</a></h3><ul><li><p><code>has_encoded_var(byte_offset: int, allow_objects: bool = false) const</code> 判断从指定字节偏移位置开始是否可以解码出合法的 Variant；默认不允许 <code>Object</code>类型。</p></li><li><p><code>hex_encode() const</code> 将数组内容编码为字符串形式的十六进制（每个字节转成两位 hex），适合调试或生成校验值等。</p></li></ul>',221)])])}const f=a(d,[["render",i]]);export{p as __pageData,f as default};
