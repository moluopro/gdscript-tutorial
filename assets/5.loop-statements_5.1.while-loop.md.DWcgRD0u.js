import{_ as i,c as a,o as t,ag as l}from"./chunks/framework.xT_8jeIh.js";const c=JSON.parse('{"title":"while循环","description":"","frontmatter":{},"headers":[],"relativePath":"5.loop-statements/5.1.while-loop.md","filePath":"5.loop-statements/5.1.while-loop.md"}'),e={name:"5.loop-statements/5.1.while-loop.md"};function p(n,s,h,k,o,d){return t(),a("div",null,[...s[0]||(s[0]=[l(`<h1 id="while循环" tabindex="-1">while循环 <a class="header-anchor" href="#while循环" aria-label="Permalink to &quot;while循环&quot;">​</a></h1><p>有时候我们希望「只要满足某个条件，就一直重复做某件事」，直到条件不再满足为止</p><p>这时候就可以使用 <code>while</code> 循环</p><h1 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h1><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (条件表达式):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    循环体</span></span></code></pre></div><blockquote><p>和if语句一样，括号不是必要的，但如果条件很长需要换行时则必须要加上括号</p></blockquote><p>当条件结果为 <code>true</code>，就会不停地执行循环体；<strong>本次循环结束后</strong>，若条件的结果变为 <code>false</code>，整个循环就会结束，程序会继续往下执行</p><h1 id="无限循环" tabindex="-1">无限循环 <a class="header-anchor" href="#无限循环" aria-label="Permalink to &quot;无限循环&quot;">​</a></h1><p>如果你的 <code>while</code> 循环条件永远不会为 <code>false</code>，那就会变成「<strong>无限循环</strong>」</p><p>无限循环将会导致程序主线程繁忙，从而使得应用未响应，也就是我们俗称的“卡死”</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This will run forever&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>我们将<code>true</code>作为了<code>while</code>的条件，而<code>true</code>是布尔值常量，它永远不可能为<code>false</code>，因此构成了一个无限循环</p><p>这段代码会疯狂输出个不停 <strong>如果你把它放进 <code>_ready</code> 或 <code>_process</code> 里运行，Godot 编辑器和游戏会直接卡死没反应</strong></p><p>这是因为主线程被彻底占用了，只能去任务管理器强制关闭进程</p><h2 id="长时间运算" tabindex="-1">长时间运算 <a class="header-anchor" href="#长时间运算" aria-label="Permalink to &quot;长时间运算&quot;">​</a></h2><p>在刚刚的测试中，我们知道了无限循环会带来怎样的后果</p><p>除了真正的无限循环，其实最常见导致游戏“卡住”的情况是——<strong>循环里做了太多事或是进行了太多次循环</strong>，比如：</p><ul><li><p>大规模计算</p></li><li><p>创建大量对象</p></li><li><p>执行特别复杂的逻辑</p></li></ul><p>这些操作虽然最终会完成，但如果耗时过长，游戏依然会看起来像是「死机」了一样</p><p>而这种情况其实可以用“协程”（<code>await</code>关键字）来解决</p><blockquote><p>此处仅提及循环的注意点，协程函数相关知识详见后续章节</p></blockquote><h1 id="迭代变量" tabindex="-1">迭代变量 <a class="header-anchor" href="#迭代变量" aria-label="Permalink to &quot;迭代变量&quot;">​</a></h1><p>在下面的例子中，我们定义了一个变量<code>count</code>，并且每次循环都会改变它的值，这就是迭代变量</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;The current count is even：&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, count)</span></span></code></pre></div><p>迭代变量在<code>while</code>语句中，一般是用于</p><ul><li><p><strong>控制循环结束</strong></p></li><li><p><strong>在循环体里参与运算</strong>（例如打印当前轮次、累加、索引等）</p></li></ul><p><strong>不要忘了在循环中更新迭代变量</strong></p><h2 id="变量作用域-重新声明" tabindex="-1">变量作用域 &amp; 重新声明 <a class="header-anchor" href="#变量作用域-重新声明" aria-label="Permalink to &quot;变量作用域 &amp; 重新声明&quot;">​</a></h2><ul><li><p><strong>在循环外声明的迭代变量</strong>（像上例的 <code>count</code>）： 只会被创建一次，每轮循环只是改变其值。</p></li><li><p><strong>在循环体内部声明的新变量</strong>（例如 <code>var temp = …</code> 放在 <code>while</code> 内）： 每次进入循环都会重新创建并初始化，上一轮的值不会保留。</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(j)            </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></div></li></ul><h1 id="练习" tabindex="-1">练习 <a class="header-anchor" href="#练习" aria-label="Permalink to &quot;练习&quot;">​</a></h1><ol><li><p>使用 <code>while</code> 打印 1 到 5 的数字</p></li><li><p>从 10 开始倒着打印，直到 1</p></li><li><p>求出从 1 加到 100 的结果，并打印它</p></li><li><p>从 1 开始不断乘2，直到结果不小于1000，打印最终的数以及它是2的几次方</p></li><li><p>打印 0 到 100 之间的所有偶数</p></li></ol>`,31)])])}const g=i(e,[["render",p]]);export{c as __pageData,g as default};
