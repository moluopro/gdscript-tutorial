import{_ as r,c as e,o as a,ag as o}from"./chunks/framework.xT_8jeIh.js";const h=JSON.parse('{"title":"结构型模式","description":"","frontmatter":{},"headers":[],"relativePath":"10.object-oriented-intro/10.7.design-patterns/10.7.2.structural-patterns/index.md","filePath":"10.object-oriented-intro/10.7.design-patterns/10.7.2.structural-patterns/index.md"}'),n={name:"10.object-oriented-intro/10.7.design-patterns/10.7.2.structural-patterns/index.md"};function p(i,t,l,s,d,g){return a(),e("div",null,[...t[0]||(t[0]=[o('<h1 id="结构型模式" tabindex="-1">结构型模式 <a class="header-anchor" href="#结构型模式" aria-label="Permalink to &quot;结构型模式&quot;">​</a></h1><blockquote><p>「怎么把零零碎碎的小部件搭起来，变成大大的系统！」</p></blockquote><p>关注如何将类或对象组合成更大结构，从而保证结构的灵活性和效率。</p><p>程序不光有“造东西”，更重要的是“把造好的东西摆好”！</p><p>如果对象关系一团乱麻，代码就难懂、难改、容易崩溃</p><p>结构型模式帮你解决：</p><ul><li><p><strong>简化复杂结构</strong>，让调用更简单</p></li><li><p><strong>保证模块之间低耦合</strong>，方便独立修改</p></li><li><p><strong>灵活扩展组件</strong>，能随时增删换装</p></li><li><p><strong>共享资源减少内存占用</strong>，效率更高</p></li></ul><h1 id="常见的结构型模式" tabindex="-1">常见的结构型模式 <a class="header-anchor" href="#常见的结构型模式" aria-label="Permalink to &quot;常见的结构型模式&quot;">​</a></h1><ul><li><p><a href="./10.7.2.1.adapter-pattern.html"><strong>适配器模式</strong>（Adapter）</a>：不兼容接口之间的桥梁</p></li><li><p><a href="./10.7.2.2.bridge-pattern.html"><strong>桥接模式</strong>（Bridge）</a>：分离抽象和实现</p></li><li><p><a href="./10.7.2.3.decorator-pattern.html"><strong>装饰器模式</strong>（Decorator）</a>：动态给对象添加功能</p></li><li><p><a href="./10.7.2.4.proxy-pattern.html"><strong>代理模式</strong>（Proxy）</a>：控制访问，添加额外操作</p></li><li><p><a href="./10.7.2.5.facade-pattern.html"><strong>外观模式</strong>（Facade）</a>：简化复杂子系统的接口</p></li><li><p><a href="./10.7.2.6.flyweight-pattern.html"><strong>享元模式</strong>（Flyweight）</a>：节约内存，享受资源共享</p></li><li><p><a href="./10.7.2.7.composite-pattern.html"><strong>组合模式</strong>（Composite）</a>：树形结构，整体与部分一致</p></li></ul>',9)])])}const u=r(n,[["render",p]]);export{h as __pageData,u as default};
