import{_ as t,c as e,o as r,ag as n}from"./chunks/framework.xT_8jeIh.js";const h=JSON.parse('{"title":"面向对象入门","description":"","frontmatter":{},"headers":[],"relativePath":"10.object-oriented-intro/index.md","filePath":"10.object-oriented-intro/index.md"}'),a={name:"10.object-oriented-intro/index.md"};function p(s,o,i,l,c,d){return r(),e("div",null,[...o[0]||(o[0]=[n('<h1 id="面向对象入门" tabindex="-1">面向对象入门 <a class="header-anchor" href="#面向对象入门" aria-label="Permalink to &quot;面向对象入门&quot;">​</a></h1><p>在前面的章节里，我们写了好多函数和变量，像在做散装工具箱：想干嘛就拼点逻辑，用完就丢</p><p>但当我们做的事情越来越复杂，比如一个角色不仅有名字、血量、还会移动攻击回血、甚至还会发怒变身……</p><p>这个时候，我们就不能再靠一堆散装函数和变量过日子了，而需要用到一个个对象（Object）</p><p>这就是——<strong>面向对象编程（Object-Oriented Programming，简称 OOP）</strong></p><h1 id="对象-object" tabindex="-1">对象（Object） <a class="header-anchor" href="#对象-object" aria-label="Permalink to &quot;对象（Object）&quot;">​</a></h1><p>现实生活中到处都是对象。</p><p>一只猫、一张桌子、一辆车，甚至一张白纸，都是<strong>拥有自己状态与行为</strong>的东西。</p><p>每个对象都是一个<strong>独立存在的个体</strong>，它们可以互相影响、互相作用</p><p>我们用两个词来描述一个对象：</p><ul><li><p><strong>属性（Property）</strong>：对象的状态，比如颜色、大小、血量……</p></li><li><p><strong>行为（Behavior）</strong>：对象能做什么，比如跳跃、行走、奔跑</p></li></ul><p>想象一张白纸它有着极强的可塑性，可被画上任何你所想的画面，也能被折成任何你所想的形状，这就是一个抽象事物逐渐具象化的过程</p><p>对象并不是凭空诞生的，它们都是<strong>由类（Class）这个蓝图造出来的</strong>。</p><p>你可以把类看作“模板”或“说明书”，</p><p>每次用这个模板造出来的，就叫做一个“对象”——也叫“实例（Instance）”。</p><blockquote><p>对象 = 类的一个具象化实例，是具有状态和行为的独立个体</p></blockquote><h1 id="类-class" tabindex="-1">类（Class） <a class="header-anchor" href="#类-class" aria-label="Permalink to &quot;类（Class）&quot;">​</a></h1><p>不能将一个事物描述成一类事物，对象是一个单一独立的个体，类则是具有相同特征和行为个体的统称</p><p>比如你有很多猫咪对象，它们颜色不同、性格不同，但都能喵喵叫、吃罐头、蹦来蹦去。这时候我们就可以说：这些猫都是“Cat”这个类的实例。</p><p>类就像是一个<strong>模板</strong>，或者<strong>设计图</strong>，它不会自己动，也没有具体的数值或状态，但它规定了对象应该“拥有什么”和“能做什么”。</p><p>类提供了：</p><ul><li><p>一组 <strong>属性（Property）定义了对象的特征</strong>（比如猫有名字、体重、毛色）</p></li><li><p>一组 <strong>方法（Method）定义了对象的行为</strong>（比如猫可以叫、跑、睡觉）</p></li></ul><p>一旦你用类创建了一个对象，这些属性和方法就会“附着”在那个对象身上，它就成为了一个可以活动的具体个体</p><p><strong>类是对象的蓝图，对象是类的具象存在。</strong></p><h1 id="三大基本特征" tabindex="-1">三大基本特征 <a class="header-anchor" href="#三大基本特征" aria-label="Permalink to &quot;三大基本特征&quot;">​</a></h1><h2 id="封装-encapsulation" tabindex="-1">封装（Encapsulation） <a class="header-anchor" href="#封装-encapsulation" aria-label="Permalink to &quot;封装（Encapsulation）&quot;">​</a></h2><p>封装是面向对象编程的核心思想，它就像给对象套上一个“保护壳”。这个壳子——就是类，它将对象的<strong>属性（数据）</strong> 和 <strong>行为（方法）</strong> 包在了一起。</p><p>但不是包在一起就完事了，重点在于：类<strong>隐藏了复杂的实现细节</strong>，对外只提供清晰好用的“使用接口”。</p><p>这个概念就是 <strong>“不要告诉我你是怎么做的，只要做就可以了。”</strong></p><p>想象一下你有一个自动贩卖机。你只要按下按钮，饮料就会掉出来～但你完全不需要知道它内部怎么运作、电路怎么连接、如何识别硬币。这就是封装！</p><p>同样地，在程序里我们也会：</p><ul><li><p><strong>隐藏内部变量和复杂逻辑</strong>（不希望被随意修改）</p></li><li><p><strong>只暴露必要的方法</strong>（让别人能安心使用）</p></li></ul><p>这样一来，不仅让程序更安全，也方便未来维护，不会因为随便改动内部数据就波及整个类</p><h2 id="继承-inheritance" tabindex="-1">继承（Inheritance） <a class="header-anchor" href="#继承-inheritance" aria-label="Permalink to &quot;继承（Inheritance）&quot;">​</a></h2><p>继承就像是对象世界里的“血脉传承”。我们可以通过一个<strong>已有的类</strong>，来创造一个<strong>新的类</strong>，这个新类自动继承了原有类的属性和行为！</p><p>这个被继承的类叫做<strong>父类（基类/超类）</strong></p><p>继承它的新类叫做<strong>子类（派生类）</strong></p><p>举个例子，你写了一个 <code>Animal</code> 类，它会 <code>move()</code> 和 <code>eat()</code>。 然后你写了一个 <code>Cat</code> 类，你不想重复这些功能，于是让 <code>Cat</code> 继承 <code>Animal</code>。<code>Cat</code> 就自动拥有了<code>move()</code> 和 <code>eat()</code> 的能力</p><p>你还可以在 <code>Cat</code> 里加上自己的特有方法，比如 <code>meow()</code>，或者重写 <code>move()</code>，让猫咪以轻盈的姿态移动</p><p><strong>需要注意的是，可以说子类的实例都是父类的实例，但不能说父类的实例是子类的实例，就好比你可以说猫是一个动物，但不能说动物都是猫</strong></p><p>使用继承可以：</p><ul><li><p><strong>复用已有代码</strong>（不需要重复写）</p></li><li><p><strong>扩展和定制功能</strong>（子类可以添加或修改行为）</p></li><li><p><strong>形成“是一个”的关系</strong>（猫 是一个 动物）</p></li></ul><h2 id="多态-polymorphism" tabindex="-1">多态（Polymorphism） <a class="header-anchor" href="#多态-polymorphism" aria-label="Permalink to &quot;多态（Polymorphism）&quot;">​</a></h2><p>多态是指<strong>相同的行为在不同的对象中可以有不同的表现</strong>。它强调的是 <strong>“统一的接口，多个不同的实现”。</strong></p><p>你可以把它理解为：虽然我们对所有对象都下达的是同一个“指令”，但每个对象会根据自己的特性，做出属于自己的反应</p><p>比如你对动物们说“开始工作”，猫咪可能是去巡视阳台，狗狗可能是去看家，小鸟可能开始唱歌——<strong>动作的“名字”是一样的，真正做的事却各有不同</strong></p><p>多态让我们在处理不同对象时，不必去关心它们的具体类型，而是相信它们都会“按规则”完成各自的事情，这让我们的程序更加灵活、简洁、容易扩展</p>',47)])])}const u=t(a,[["render",p]]);export{h as __pageData,u as default};
