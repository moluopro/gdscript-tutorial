import{_ as i,c as a,o as n,ag as p}from"./chunks/framework.xT_8jeIh.js";const c=JSON.parse('{"title":"类","description":"","frontmatter":{},"headers":[],"relativePath":"10.object-oriented-intro/10.1.class.md","filePath":"10.object-oriented-intro/10.1.class.md"}'),t={name:"10.object-oriented-intro/10.1.class.md"};function l(h,s,e,k,r,d){return n(),a("div",null,[...s[0]||(s[0]=[p(`<h1 id="类" tabindex="-1">类 <a class="header-anchor" href="#类" aria-label="Permalink to &quot;类&quot;">​</a></h1><p>类是一种用来组织代码的数据结构，它可以包含：</p><ul><li><p><strong>数据成员</strong>（如变量和常量）</p></li><li><p><strong>函数成员</strong>（如方法、属性、构造函数、析构函数等）</p></li><li><p><strong>嵌套类型</strong>（类中套类）</p></li></ul><p>它是构造对象的蓝图，定义了某种对象的属性和行为</p><h1 id="类的声明" tabindex="-1">类的声明 <a class="header-anchor" href="#类的声明" aria-label="Permalink to &quot;类的声明&quot;">​</a></h1><p>在GDScript中你可以声明三种类：</p><ul><li><p>无名类：GDScript中类的默认形式，要在其他地方使用该类不够方便</p></li><li><p>具名类（全局类）：使用 <code>class_name</code> 注册为全局，可以在任何脚本直接访问的唯一的类</p></li><li><p>内部类：类内部的类，与无名和具名类具有不同的作用域</p></li></ul><h3 id="无名类" tabindex="-1">无名类 <a class="header-anchor" href="#无名类" aria-label="Permalink to &quot;无名类&quot;">​</a></h3><p>在 GDScript 中，每个脚本文件本身就是一个类，默认是“无名”的。</p><p>所以一般写脚本时不需要特别声明类名，但这样有个小麻烦：<strong>你无法直接通过类名来引用它</strong>，而是必须使用脚本路径进行加载与实例化。</p><p>举个例子： 假如你有一个脚本叫 <code>character.gd</code>，你想在其他地方使用它，要这样写：</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 继承 &#39;character.gd&#39;.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extends</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;res://path/to/character.gd&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 加载脚本资源，创建该类的实例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Character</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;res://path/to/character.gd&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> character_node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Character</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="具名类" tabindex="-1">具名类 <a class="header-anchor" href="#具名类" aria-label="Permalink to &quot;具名类&quot;">​</a></h3><p>使用 <code>class_name</code> 关键字可以给类起个名字，并注册为全局类，这样在任何地方你都可以直接用这个名字来访问类，不用再写路径了！</p><p>比如你把 <code>character.gd</code> 改成这样：</p><blockquote><p>在GDScript中，类名的标识符一般使用大帕斯卡命名法，即标识符的每个单词首字母大写</p></blockquote><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># &#39;character.gd&#39;.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class_name</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Character</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> health </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> print_health</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(health)</span></span></code></pre></div><p>这样你就可以这样使用它：</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 继承它</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Chararcter</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 创建它的一个实例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Character</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>而且还可以从 <code>get_script()</code>、<code>ResourceLoader</code> 和类名直接访问同一个资源，说明它们是同一个脚本引用：</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get_script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ResourceLoader</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;res://character.gd&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Character</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="内部类" tabindex="-1">内部类 <a class="header-anchor" href="#内部类" aria-label="Permalink to &quot;内部类&quot;">​</a></h3><p>你也可以在类中使用<code>class</code>关键字定义一个类，我们称之为“内部类”。它可以嵌套在另一个类中，组织结构更清晰</p><blockquote><p>内部类也允许嵌套内部类</p></blockquote><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class_name</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyInnerClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> print_a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a)</span></span></code></pre></div><p>访问内部类有两种方式，取决于在哪个地方使用：</p><ul><li><p><strong>在当前文件中访问：</strong> <code>MyInnerClass.new()</code></p></li><li><p><strong>在其他脚本中访问：</strong> <code>MyClass.MyInnerClass.new()</code></p></li></ul><h2 id="类的成员" tabindex="-1">类的成员 <a class="header-anchor" href="#类的成员" aria-label="Permalink to &quot;类的成员&quot;">​</a></h2><p>类中可以包含<strong>字段（变量）</strong>、<strong>属性</strong>、<strong>方法（函数成员）以及信号</strong>等内容，统称为类的成员。</p><p><strong>在 GDScript 中，我们通常用下划线 <code>_</code> 前缀来标记不希望被外部访问的成员，例如 <code>_my_property</code>、<code>_my_function</code>，以示“内部使用”或“私有”。</strong></p><h3 id="字段-field" tabindex="-1">字段（Field） <a class="header-anchor" href="#字段-field" aria-label="Permalink to &quot;字段（Field）&quot;">​</a></h3><p>字段是类中最基础的变量形式，没有封装行为，外部可以直接读取或修改，因此通常只用于类的内部逻辑。</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class_name</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Player</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_health </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> health </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> speed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span></span></code></pre></div><p>在上例中，<code>health</code> 和 <code>speed</code> 是字段，没有访问控制。<strong><code>const</code> 常量也是一种字段，只不过是只读的</strong></p><h3 id="属性-property" tabindex="-1">属性（Property） <a class="header-anchor" href="#属性-property" aria-label="Permalink to &quot;属性（Property）&quot;">​</a></h3><p>属性是通过 <code>get</code> / <code>set</code> 方法控制访问的数据成员。它是对字段的封装，可以用来添加验证逻辑、触发信号，或者只读访问等。</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class_name</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Player</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">signal</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hp_changed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(old_value: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, new_value: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_health </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 9999</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> health: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> health</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> health:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_health:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_health</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        elif</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> old_val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> health</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        health </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        hp_changed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(old_val, health)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> speed: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _speed</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _speed: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span></span></code></pre></div><p>可以看到，我们在<code>health</code>的 <code>set</code> 中对数值进行了范围限制，并发射了 <code>hp_changed</code> 信号，在<code>speed</code>的<code>get</code>中令它始终返回<code>_speed</code>，这使其成为了一个只读属性</p><p>有一点需要特殊说明，在 <strong>GDScript</strong> 中，即使字段（如 <code>var my_var = 123</code>）没有显式声明 getter/setter，也仍然被称为“属性” 。这是因为在 GDScript 中，“属性”这个概念被广义地用于表示任何类中的成员变量，无论它是否封装了访问逻辑。</p><p>和传统的 OOP 比起来，这里“属性”更像是一个 <em>语义标签</em>，而不是访问机制上的明确区分。也就是说：</p><ul><li><p><strong>传统 OOP 语言</strong>（比如 C#、Java）：字段和属性是严格区分的，属性通常代表有访问器封装的字段。</p></li><li><p><strong>GDScript 中</strong>：字段默认就属于属性范畴了，只是没有自定义访问逻辑而已</p></li></ul><h4 id="属性访问器" tabindex="-1">属性访问器 <a class="header-anchor" href="#属性访问器" aria-label="Permalink to &quot;属性访问器&quot;">​</a></h4><p>属性的 <code>get</code> 和 <code>set</code> 可以采用<strong>匿名</strong>或<strong>具名</strong>方式</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 匿名</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> my_prop:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 具名</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> my_prop:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    get </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> get_my_prop, set </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> set_my_prop</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> my_prop: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get_my_prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set_my_prop</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 允许写在同一行</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_my_prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> set_my_prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    ...</span></span></code></pre></div><p>这里使用了显式声明的getter/setter成员函数来作为属性访问器，同时，它们也必须要具备和匿名属性访问器相同的签名</p><ul><li><p>getter: 不接收参数，返回值为获取到的对应属性的值，其类型为属性的类型</p></li><li><p>setter：无返回值，接收一个对应属性类型的参数，表示要设置的新值</p></li></ul><p>在访问器内部使用自身属性时，<strong>不会递归</strong>！这点 GDScript 非常贴心～但是注意，如果你在访问器中调用了另一个函数，而那个函数又访问了同一个属性，就会出现无限递归</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 不会导致无限递归</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">signal</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> changed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(new_value)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> warns_when_changed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;some value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> warns_when_changed</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        changed</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        warns_when_changed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> my_prop: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set_my_prop</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> set_my_prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    my_prop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 在访问器中调用其他函数，而该函数访问该属性，会导致无限递归</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> my_prop:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value):</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        set_my_prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> set_my_prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    my_prop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value</span></span></code></pre></div><h3 id="构造函数-constructor" tabindex="-1">构造函数（Constructor） <a class="header-anchor" href="#构造函数-constructor" aria-label="Permalink to &quot;构造函数（Constructor）&quot;">​</a></h3><p>构造函数，又名构造器（Constructor）是类创建实例时自动调用的特殊函数。它可以用于初始化属性、设置状态等。</p><p>默认情况下，每个类都有一个无参构造函数，也可以显式声明类的构造函数</p><p>类的构造函数名为<code>_init</code>，你可以随意更改其所需的参数</p><p><strong>但注意：如果<code>_init</code>中定义了必填参数则该类只能使用代码来实例化，其他任何方式（例如<code>PackedScene.instantiate()</code> 或 <code>Node.duplicate()</code>）创建时，该类的初始化都将失败，因为Godot无法为其填充所需的参数</strong></p><p><strong>编写了具有参数的构造函数的脚本，不能挂载到节点上，如果是自定义资源，也不能用ResourceLoader来加载</strong></p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class_name</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Item</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item_name: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item_name</span></span></code></pre></div><h3 id="静态构造函数-static-constructor" tabindex="-1">静态构造函数（Static Constructor） <a class="header-anchor" href="#静态构造函数-static-constructor" aria-label="Permalink to &quot;静态构造函数（Static Constructor）&quot;">​</a></h3><p>静态构造函数<code>_static_init</code>会在类第一次被加载或其静态变量初始化后执行一次，一般用于初始化静态字段。</p><p><strong>与实例构造函数不同，静态构造函数不能添加参数，静态构造函数会先于实例构造函数执行</strong></p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> my_static_var </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _static_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        my_static_var </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span></code></pre></div><h3 id="析构函数-destructor" tabindex="-1">析构函数（Destructor） <a class="header-anchor" href="#析构函数-destructor" aria-label="Permalink to &quot;析构函数（Destructor）&quot;">​</a></h3><p>析构函数（Destructor），又称析构器、终结器，它会在对象即将被销毁时调用，做最后的清除工作。</p><p>GDScript 没有传统意义的析构函数，但可以使用 <code>_notification</code> 接收生命周期通知。对象即将被销毁时会收到 <code>NOTIFICATION_PREDELETE</code> 通知，这时就可以做清理工作</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _notification</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(what: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> what </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NOTIFICATION_PREDELETE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;再见&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="方法-method" tabindex="-1">方法(Method) <a class="header-anchor" href="#方法-method" aria-label="Permalink to &quot;方法(Method)&quot;">​</a></h3><p>方法用来定义类可用的行为，方法其实就是我们之前所学的函数，现在只是换了一个更“面向对象”的名字，现在让我们来重新认识一下它</p><p>声明方法的格式如下</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 方法名(参数列表) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 返回值类型:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 方法具体实现</span></span></code></pre></div><p>返回值用于定义方法返回数据的类型，如果不需要返回一个值则使用<code>void</code>关键字，如果定义的方法有返回值，则必须使用<code>return</code>关键字在所有的代码执行路径返回一个指定类型的数据。</p><p>返回值类型在声明方法时可以省略，此时方法的返回值类型为<code>Variant</code></p><p>调用方法时可以给该方法传递对应数量的值，传给方法的值叫作实参，即方法参数的实际值，在方法内部接收实参的变量叫作形参</p><p>形参在紧跟着方法名的括号中声明，方法可以有零或多个形参，形参的定义和变量类似，但不需要写 <code>var</code>，多个参数之间用英文逗号隔开。</p><p>形参只在方法内部有效，方法的参数始终按值传递，调用方法传参时，会将实参的值复制到形参中，因此在方法内部对参数的修改不会影响到外部传入的值。</p><p>在 GDScript 中，方法可以接受三种类型的参数，分别是：</p><h4 id="_1-必选参数-required-parameters" tabindex="-1">1. 必选参数（Required Parameters） <a class="header-anchor" href="#_1-必选参数-required-parameters" aria-label="Permalink to &quot;1. 必选参数（Required Parameters）&quot;">​</a></h4><p>这是最基本的参数类型，调用方法时必须传入值</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    pass</span></span></code></pre></div><h4 id="_2-可选参数-optional-parameters" tabindex="-1">2. 可选参数（Optional Parameters） <a class="header-anchor" href="#_2-可选参数-optional-parameters" aria-label="Permalink to &quot;2. 可选参数（Optional Parameters）&quot;">​</a></h4><p>只要给参数一个默认值，它就变成可选的</p><p>可选参数必须放在必选参数之后（否则会语法错误），可以根据需要传或不传</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    pass</span></span></code></pre></div><h4 id="_3-剩余参数-可变参数-rest-parameters-godot-4-5-新特性" tabindex="-1">3. 剩余参数 / 可变参数（Rest Parameters）（Godot 4.5+ 新特性） <a class="header-anchor" href="#_3-剩余参数-可变参数-rest-parameters-godot-4-5-新特性" aria-label="Permalink to &quot;3. 剩余参数 / 可变参数（Rest Parameters）（Godot 4.5+ 新特性）&quot;">​</a></h4><p>当你想要一个方法能接受任意数量的额外参数时，就可以使用剩余参数 它的类型必须是 <code>Array</code>，写法是在参数前加三个点（<code>...</code>），而且必须放在参数列表的最后一位！</p><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ...args: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg)</span></span></code></pre></div><div class="language-gdscript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">gdscript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># args 就会是 [&quot;hello&quot;, 42, true]</span></span></code></pre></div><h3 id="信号-signal" tabindex="-1">信号（Signal） <a class="header-anchor" href="#信号-signal" aria-label="Permalink to &quot;信号（Signal）&quot;">​</a></h3><p>信号是类的一种成员，用于定义“事件”。你可以将它理解为“这个类可以发出的某种通知”。</p><p>我们之前已经在信号章节详细讲过信号的使用和定义方式，这里就不赘述了</p><h3 id="常量成员-constant-member" tabindex="-1">常量成员（Constant Member） <a class="header-anchor" href="#常量成员-constant-member" aria-label="Permalink to &quot;常量成员（Constant Member）&quot;">​</a></h3><p>类中还可以包含一些不可变的常量数据，它们是类的静态特征之一，通常有三种形式：</p><ol><li><p><strong>常量（Constant）</strong>：使用 <code>const</code> 定义，是类的字段，值在声明时设定后就不能再改变。</p></li><li><p><strong>枚举（Enum）</strong>：使用 <code>enum</code> 定义的值集合，在 GDScript 中属于类的常量成员，可用作类型，也可当作只读字典使用。</p></li><li><p><strong>内部类（Inner Class）</strong>：使用 <code>class</code> 定义在类内部的类，本质上也被当作一种类的常量成员。</p></li></ol><h1 id="gdscript中类的本质" tabindex="-1">GDScript中类的本质 <a class="header-anchor" href="#gdscript中类的本质" aria-label="Permalink to &quot;GDScript中类的本质&quot;">​</a></h1><p>在 Godot 中，我们通常使用“类”这个术语来描述可复用的对象模板。但和传统编程语言不同，Godot 引擎底层并没有真正以我们熟悉的那种方式定义类，而是提供了两种主要的可复用结构：</p><h3 id="脚本-script" tabindex="-1">脚本（Script） <a class="header-anchor" href="#脚本-script" aria-label="Permalink to &quot;脚本（Script）&quot;">​</a></h3><p>脚本其实本质上是一种资源，而非传统意义上的“类”。它的作用是告诉引擎：在某个已有的内置类（比如 Node、Control 等）上，添加一些自定义的行为和属性。</p><p>当你创建一个脚本时，Godot 会将其注册进一个叫做 <code>ClassDB</code> 的类数据库中，这个数据库在运行时负责保存并提供类的信息，包括：</p><ul><li><p>属性</p></li><li><p>方法</p></li><li><p>常量</p></li><li><p>信号</p></li></ul><p>当游戏运行中访问对象的属性或调用方法时，Godot 就会通过 <code>ClassDB</code> 来判断该操作是否被支持。 简单来说，<strong>脚本就是 ClassDB 中为某个对象“扩展”的部分</strong>，它定义了这个对象的额外行为。</p><p>所以我们虽然说写了一个“类”，但其实我们写的是“在某个 Godot 类型上添加行为的脚本”。</p><h3 id="场景-scene" tabindex="-1">场景（Scene） <a class="header-anchor" href="#场景-scene" aria-label="Permalink to &quot;场景（Scene）&quot;">​</a></h3><p>虽然场景看上去和脚本很不一样，但其实也可以被看作是一种“类”</p><p>场景是一组组织好的节点，可以被复用、实例化、继承。这就像是在写一个类，其中“属性”就是各个子节点，“行为”则由脚本定义。</p><p>通常我们会在场景的<strong>根节点</strong>上挂载一个脚本，然后这个脚本就可以操作这个场景的所有子节点，定义他们的交互、状态等等。 在这种结构中，<strong>脚本通过命令式逻辑，为整个场景添加了行为</strong>，而场景本身也成了类的一部分。</p><p>场景的内容决定了：</p><ul><li><p>你可以访问哪些节点</p></li><li><p>节点之间如何组织</p></li><li><p>它们是如何初始化的</p></li><li><p>它们之间有哪些信号连接</p></li></ul><p>因此，许多面向对象编程的原则同样适用于场景的设计，比如：</p><ul><li><p>单一职责</p></li><li><p>封装</p></li><li><p>重用</p></li></ul><p>你可以将一个场景类比为<strong>一个“类 + 实例化模板”的组合体</strong>，它既包括了对象的结构，也可以附加行为（脚本），非常灵活又高效</p><h1 id="练习" tabindex="-1">练习 <a class="header-anchor" href="#练习" aria-label="Permalink to &quot;练习&quot;">​</a></h1><ol><li><p>定义一个<code>Dog</code>类，包含<code>name</code>和<code>age</code>字段，一个方法 <code>bark()</code>，会输出 <code>&quot;汪汪！我是[name]！&quot;</code></p></li><li><p>扩展上题的 <code>Dog</code> 类，现在要求：</p><ul><li><p>将 <code>age</code> 字段设为私有（不希望让外部访问）</p></li><li><p>提供一个方法 <code>set_age(value)</code> 来设置年龄</p></li><li><p>提供一个方法 <code>get_age()</code> 来获取年龄</p></li></ul></li></ol>`,109)])])}const o=i(t,[["render",l]]);export{c as __pageData,o as default};
