import{_ as e,c as a,o as r,ag as i}from"./chunks/framework.xT_8jeIh.js";const c=JSON.parse('{"title":"行为型模式","description":"","frontmatter":{},"headers":[],"relativePath":"10.object-oriented-intro/10.7.design-patterns/10.7.3.behavioral-patterns/index.md","filePath":"10.object-oriented-intro/10.7.design-patterns/10.7.3.behavioral-patterns/index.md"}'),l={name:"10.object-oriented-intro/10.7.design-patterns/10.7.3.behavioral-patterns/index.md"};function p(n,t,o,s,h,d){return r(),a("div",null,[...t[0]||(t[0]=[i('<h1 id="行为型模式" tabindex="-1">行为型模式 <a class="header-anchor" href="#行为型模式" aria-label="Permalink to &quot;行为型模式&quot;">​</a></h1><blockquote><p>怎么在对象之间通信，优雅地完成任务</p></blockquote><p>关注的是如何让多个对象之间<strong>优雅地协作完成某个任务</strong>，而不是一锅炖地互相调用得乱七八糟</p><p>举个例子：</p><ul><li><p>你是一个“角色状态机”，不同状态之间怎么切换？</p></li><li><p>你是个“UI按钮”，点击后要通知谁？谁来响应？</p></li><li><p>你在做日志系统，怎么统一调度每条日志？</p></li></ul><p>这些，都属于“<strong>行为如何组织</strong>”的问题，而不是“结构怎么搭”、“对象如何创建”。</p><h1 id="_11个行为型模式" tabindex="-1">11个行为型模式 <a class="header-anchor" href="#_11个行为型模式" aria-label="Permalink to &quot;11个行为型模式&quot;">​</a></h1><ul><li><p><a href="./10.7.3.1.chain-of-responsibility.html">责任链（Chain of Responsibility）</a>：多个处理者排成一列，按顺序处理请求</p></li><li><p><a href="./10.7.3.2.command-pattern.html">命令（Command）</a>：将请求封装为命令对象，支持撤销、记录、延迟等操作</p></li><li><p><a href="./10.7.3.3.interpreter-pattern.html">解释器（Interpreter）</a>：用于构建简单的解释器（如逻辑表达式、公式）（较少使用）。</p></li><li><p><a href="./10.7.3.4.iterator-pattern.html">迭代器（Iterator）</a>：统一集合遍历方式，封装内部结构</p></li><li><p><a href="./10.7.3.5.mediator-pattern.html">中介者（Mediator）</a>：用中心化对象管理多个对象之间的交互</p></li><li><p><a href="./10.7.3.6.memento-pattern.html">备忘录（Memento）</a>：保存对象状态以支持撤销、恢复等操作</p></li><li><p><a href="./10.7.3.7.observer-pattern.html">观察者（Observer）</a>：一改多联动，变化时通知所有订阅者</p></li><li><p><a href="./10.7.3.9.state-pattern.html">状态（State）</a>：对象状态不同行为也不同，用状态类封装变化</p></li><li><p><a href="./10.7.3.8.strategy-pattern.html">策略（Strategy）</a>：封装不同算法，按需动态选择</p></li><li><p><a href="./10.7.3.10.template-method-pattern.html">模板方法（Template Method）</a>：定义流程骨架，子类决定某些步骤</p></li><li><p><a href="./10.7.3.11.visitor-pattern.html">访问者（Visitor）</a>：把“对数据的操作”封装在访问者里</p></li></ul>',8)])])}const f=e(l,[["render",p]]);export{c as __pageData,f as default};
